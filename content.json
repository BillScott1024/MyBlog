{"meta":{"title":"忆星辰","subtitle":"个人博客","description":"星辰的个人博客","author":"Akimoto","url":"https://www.extingstudio.com","root":"/"},"pages":[{"title":"","date":"2020-08-27T06:34:04.814Z","updated":"2019-12-25T21:16:35.000Z","comments":true,"path":"webpushr-sw.js","permalink":"https://www.extingstudio.com/webpushr-sw.js","excerpt":"","text":"importScripts(\"https://cdn.webpushr.com/sw-server.min.js\");"},{"title":"404 Not Found","date":"2020-08-25T02:24:19.282Z","updated":"2020-08-25T02:24:19.282Z","comments":true,"path":"404.html","permalink":"https://www.extingstudio.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-08-26T01:55:50.509Z","updated":"2020-08-26T01:55:50.509Z","comments":true,"path":"about/index.html","permalink":"https://www.extingstudio.com/about/index.html","excerpt":"","text":"一个游戏开发者，业余摄影师，喜欢旅行，读书，看电影。 技术栈 blue 游戏引擎: Cocos/Laya/Unity blue 语言: JavaScript(TypeScript)/C#"},{"title":"所有分类","date":"2020-08-25T07:28:29.967Z","updated":"2020-08-25T07:28:29.967Z","comments":true,"path":"categories/index.html","permalink":"https://www.extingstudio.com/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-08-25T02:24:19.287Z","updated":"2020-08-25T02:24:19.287Z","comments":true,"path":"comments/index.html","permalink":"https://www.extingstudio.com/comments/index.html","excerpt":"","text":"欢迎留言"},{"title":"我的朋友们","date":"2020-08-25T02:24:19.287Z","updated":"2020-08-25T02:24:19.287Z","comments":true,"path":"friends/index.html","permalink":"https://www.extingstudio.com/friends/index.html","excerpt":"","text":"友链规范:请按以下规则发送友链给博主： name: # 博客名 avatar: # 头像链接 url: # 博客链接 backgroundColor: ‘#3E7411’ # 卡片背景颜色 textColor: ‘#fff’ # 卡片文字颜色 tags: [标签1, 标签2] # 标签 desc: 描述文字 示例: name: 星辰 # 博客名 avatar: https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/avatar.jpg # 头像链接 url: https://www.extingstudio.com/ # 博客链接 backgroundColor: ‘#3E74C9’ # 卡片背景颜色 textColor: ‘#fff’ # 卡片文字颜色 tags: [游戏开发者, 业余摄影师] # 标签 desc: Programmer"},{"title":"","date":"2020-08-25T02:24:19.288Z","updated":"2020-08-25T02:24:19.288Z","comments":true,"path":"mylist/index.html","permalink":"https://www.extingstudio.com/mylist/index.html","excerpt":"","text":""},{"title":"说说","date":"2020-08-25T02:24:19.288Z","updated":"2020-08-25T02:24:19.288Z","comments":false,"path":"shuoshuo/index.html","permalink":"https://www.extingstudio.com/shuoshuo/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-08-25T02:24:19.288Z","updated":"2020-08-25T02:24:19.288Z","comments":true,"path":"tags/index.html","permalink":"https://www.extingstudio.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"在GitHub仓库使用Git命令 遇到ssh_exchange_identification错误的解决办法","slug":"2020-08-10-GitHub-Error","date":"2020-08-09T16:00:00.000Z","updated":"2020-08-25T07:42:10.320Z","comments":true,"path":"2020/08/10/2020-08-10-GitHub-Error/","link":"","permalink":"https://www.extingstudio.com/2020/08/10/2020-08-10-GitHub-Error/","excerpt":"","text":"前言 记录一次遇到在GitHub上使用Git命令Pull仓库遇到的“疑难杂症”。 起因起因是我写了一个Cocos Creator的通用的组件代码，想在GitHub上的个人仓库中保存下来，方便分享给他人，也以便今后自己用到方便查看，于是在GitHub上新建了一个公开的仓库，地址是：RichTextTypingDemo， 然后在本地使用SourceTree去拉取Git仓库到本地，但是一直在加载，过一会儿就出现报错：点开报错信息后显示： 123456789101112131415161718ssh_exchange_identification: read: Operation timed outfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.fatal: not a git repository (or any of the parent directories): .gitssh_exchange_identification: read: Operation timed outfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.ssh_exchange_identification: read: Operation timed outfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 使用Git命令报错： 123456git pull --rebasessh_exchange_identification: read: Operation timed outfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 解决过程 我开始以为是我的GitHub的权限问题，或者是我的SSH 私钥Key过期了，因为我看到报错信息里有：Please make sure you have the correct access rights 于是删除了本地的SSH Key，并重新生成私钥，保存到GitHub的后台上，但重试后问题依旧。排除权限问题。 然后我怀疑的原因是可能是我的梯子有问题，导致我的SourceTree无法链接GitHub的仓库，于是我打开Chrome进GitHub，连接正常，打开关闭ClashX Pro都可以正常进入GitHub主页，但是有可能是浏览器可以正常进去，但是命令行无法进入，我打开iTerm Ping了一下GitHub.com，果然无法Ping通,全都超时了： 于是我把ClashX Pro提供的命令行翻♂墙命令export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890， 复制到iTerm中，依然无法Ping通，百度是可以正常Ping通的，排除WiFi网络问题: 网上搜索了一番，没有找到解决问题的方法。但我突然想起来，我之前改过一次GitHub的Host，有可能是这个原因导致的于是找到Mac的Host文件，删除GitHub的Host： Binggo！解决问题,代码仓库可以正常Pull和Push了： 当初改这个Host的原因是我的GitHub和WIki上所有的用户头像和图标都无法加载，显示裂开，在网上找到的修改Host的方法解决的，现在删掉这条Host好像也没有问题了。 到此，问题解决完毕。","categories":[{"name":"Git","slug":"Git","permalink":"https://www.extingstudio.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.extingstudio.com/tags/Git/"}]},{"title":"JavaScript深入浅出之理解闭包","slug":"2019-11-23-Closure-in-JavaScript","date":"2019-11-22T16:00:00.000Z","updated":"2020-08-25T07:42:01.599Z","comments":true,"path":"2019/11/23/2019-11-23-Closure-in-JavaScript/","link":"","permalink":"https://www.extingstudio.com/2019/11/23/2019-11-23-Closure-in-JavaScript/","excerpt":"","text":"前言 函数与对其状态即词法环境（lexical environment）的引用共同构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在JavaScript，函数在每次创建时生成闭包。— MDN Web docs 什么是“闭包”在MDN JavaScript官方文档上对“闭包”的描述是：函数与其状态即词法环境的引用，共同构成闭包。用更通俗的话来讲就是：闭包就是能够读取其他函数内部变量的函数。简单来说，闭包是一种函数，一种定义在函数内部的函数。本质上，闭包就是将函数内部和外部连接在一起的一座桥梁。例子🌰： 12345678910111213function func1()&#123; var number = 999; function func2()&#123; console.log(number); &#125; return func2();&#125;var result = func1();result(); // &quot;999&quot;var function()&#123;&#125; 其中 func2函数，就是闭包。 闭包的作用 在外部能够读取函数内部的变量。 使变量的值一直存在于内存当中。 使用闭包模拟私有方法。 示例代码： 12345678910111213141516function func1()&#123; var number = 999; addFunc = function()&#123; number += 1; &#125; function func2()&#123; console.log(number); &#125; return func2;&#125;var result = func1();result(); // &quot;999&quot;addFunc();result(); //&quot;1000&quot; 闭包会产生的问题（注意事项） 由于闭包会使得函数中的变量都被保存在内存之中，即使函数已经执行完毕，这些局部变量也不会被垃圾回收器自动回收，有某些环境下容易导致内存泄漏。正确做法是，在退出函数之前，将不使用的变量都删除清空。 闭包会改变函数的值，而不只是改变函数变量的一个副本。 循环闭包问题。 引用本文参考： 学习Javascript闭包（Closure）闭包用9种办法解决 JS 闭包经典面试题","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.extingstudio.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.extingstudio.com/tags/JavaScript/"}]},{"title":"JavaScript中的内存管理机制","slug":"2019-11-19-JavaScript-Memory-Management","date":"2019-11-18T16:00:00.000Z","updated":"2020-08-25T07:41:47.442Z","comments":true,"path":"2019/11/19/2019-11-19-JavaScript-Memory-Management/","link":"","permalink":"https://www.extingstudio.com/2019/11/19/2019-11-19-JavaScript-Memory-Management/","excerpt":"","text":"垃圾回收是一种自动的内存管理机制。当计算机上的动态内存不再需要的时候，就应当予以释放，以让出内存。直白点讲，就是程序是运行在内存里的，当声明一个变量、定义一个函数时都会占用内存。内存的容量是有限的，如果变量函数等只有产生没有消亡的过程，那内存总有会被完全占用的时候。这个时候，不仅程序自己无法正常运行，连其他程序都会受到影响。所以，在计算机当中，我们需要垃圾回收。需要注意的时候，JavaScript定义中的“自动”的意思是预言可以帮助我们回收内存垃圾，但并不代表我们不用关心内存管理，如果使用不当，JS中依旧会出现内存溢出的情况 — 知乎 简介像C预言这样的底层语言一般都有底层的内存管理接口，比如malloc()和free()。而JavaScript（以下简称JS）是在创建变量(对象，字符串等)时自动进行了内存分配，并且在不使用他们时“自动释放”。释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。 内存生命周期不管什么程序语言，内存生命周期基本是一致的： 分配你所需要的内存 使用分配到的内存(读,写) 不需要时将其归还释放 所有语言的第一，第二部分都很清晰，第三步在低级语言（例如C语言）很清晰，但是在JavaScript这样的高级语言中，大部分是隐含的。因为JS具有自动垃圾回收机制（Garbage Collected）。但是作为开发者仍然需要关系内存的管理，因为这种自动回收机制，并不咋任何情况下都是智能的，仍会有发生内存泄漏的风险。 JavaScript的内存分配值的初始化JS在定义变量的时候完成内存分配 12345678910111213var n &#x3D; 123; &#x2F;&#x2F; 给数值变量分配内存var str &#x3D; &quot;hello&quot;; &#x2F;&#x2F;给字符串分配内存var obj &#x3D; &#123; index: 0, name: null&#125;; &#x2F;&#x2F;给对象和对象的值分配内存var array &#x3D; [1,2,3]; &#x2F;&#x2F;给数组分配内存function func(num)&#123; &#x2F;&#x2F;给函数分配内存 return num + 1;&#125; 通过函数调用分配内存有些函数调用的结果是分配对象内存 123var data &#x3D; new Data(); &#x2F;&#x2F;分配一个Data对象var element &#x3D; document.createElement(&#39;div&#39;); &#x2F;&#x2F;分配一个DOM对象 有些方法分配新变量或者新对象 12345678910var s &#x3D; &quot;azerty&quot;;var s2 &#x3D; s.substr(0, 3); &#x2F;&#x2F; s2 是一个新的字符串&#x2F;&#x2F; 因为字符串是不变量，&#x2F;&#x2F; JavaScript 可能决定不分配内存，&#x2F;&#x2F; 只是存储了 [0-3] 的范围。var a &#x3D; [&quot;ouais ouais&quot;, &quot;♂ ♂&quot;];var a2 &#x3D; [&quot;generation&quot;, &quot;♂ ♂&quot;];var a3 &#x3D; a.concat(a2); &#x2F;&#x2F; 新数组有四个元素，是 a 连接 a2 的结果 值的使用使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。 内存不再需要使用时释放大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“哪些被分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。 高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。 垃圾回收引用垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。 在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。 引用计数（Reference Counting）这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 12345678910111213141516171819202122var o &#x3D; &#123; a: &#123; b:2 &#125;&#125;; &#x2F;&#x2F; 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o&#x2F;&#x2F; 很显然，没有一个可以被垃圾收集var o2 &#x3D; o; &#x2F;&#x2F; o2变量是第二个对“这个对象”的引用o &#x3D; 1; &#x2F;&#x2F; 现在，“这个对象”的原始引用o被o2替换了var oa &#x3D; o2.a; &#x2F;&#x2F; 引用“这个对象”的a属性&#x2F;&#x2F; 现在，“这个对象”有两个引用了，一个是o2，一个是oao2 &#x3D; &quot;yo&quot;; &#x2F;&#x2F; 最初的对象现在已经是零引用了 &#x2F;&#x2F; 他可以被垃圾回收了 &#x2F;&#x2F; 然而它的属性a的对象还在被oa引用，所以还不能回收oa &#x3D; null; &#x2F;&#x2F; a属性的那个对象现在也是零引用了 &#x2F;&#x2F; 它可以被垃圾回收了 限制：循环引用该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。 12345678910function f()&#123; var o &#x3D; &#123;&#125;; var o2 &#x3D; &#123;&#125;; o.a &#x3D; o2; &#x2F;&#x2F; o 引用 o2 o2.a &#x3D; o; &#x2F;&#x2F; o2 引用 o return &quot;azerty&quot;;&#125;f(); 标记清除（Mark and Sweep）JavaScript 中有个全局对象，浏览器中是 window。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象…对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。标记－清除法的一个问题就是不那么有效率，因为在标记－清除阶段，整个程序将会等待，所以如果程序出现卡顿的情况，那有可能是收集垃圾的过程。2012 年起，所有现代浏览器都使用了这个方法，所有的改进也都是基于这个方法，比如标记-整理方法：标记清除有一个问题，就是在清除之后，内存空间是不连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而标记-整理方法可以有效地解决这个问题。标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。不过可以想象，这种做法的效率没有标记-清除高。计算机中的很多做法都是互相妥协的结果，哪有什么十全十美的事儿呢。 那标记清除具体是如何呢？有以下几种算法： 在JavaScript 中，全局变量（Global）和window 对象会一直存在，不会被垃圾收集器回收； 递归所用到的所有（包括变量和方法），都不会被回收； 所有没有被标记为“活跃（active）”的，都会被认为是垃圾，收集器释放会回收垃圾，并把内存还给操作系统。 内存泄露什么是内存泄漏？内存泄漏指的是计算机可用内存越来越少，主要是因为程序无法自动释放那些不再使用的内存。 导致内存泄漏的原因有几种。 1 循环引用就是上面介绍的循环引用的例子🌰。标记-清除算法可以解决这个问题。在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。 2 无意的全局变量有时候本希望声明一个局部变量却无意声明了一个全局变量，这个全局变量会得到window的引用（在浏览器中），bar 实际上是window.bar,它的作用域在window上，所以当foo方法执行结束后，它也不会被回收。 12345function foo(arg) &#123; bar &#x3D; &quot;&quot;;&#125;foo(); 同理： 123function foo() &#123; this.bar &#x3D; &quot;&quot;;&#125; foo方法为全局方法，其中的this指向window，在类中指向类。 3 未取消的计时器和回调函数1234567let someResource &#x3D; getData();setInterval(() &#x3D;&gt; &#123; const node &#x3D; document.getElementById(&#39;Node&#39;); if(node) &#123; node.innerHTML &#x3D; JSON.stringify(someResource)); &#125;&#125;, 1000); 上面的例子中，我们每隔一秒就将得到的数据放入到文档节点中去。但在 setInterval 没有结束前，回调函数里的变量以及回调函数本身都无法被回收。那什么才叫结束呢？就是调用了 clearInterval。如果回调函数内没有做什么事情，并且也没有被 clear 掉的话，就会造成内存泄漏。不仅如此，如果回调函数没有被回收，那么回调函数内依赖的变量也没法被回收。上面的例子中，someResource 就没法被回收。同样的，setTiemout 也会有同样的问题。所以，当不需要 interval 或者 timeout 时，最好调用 clearInterval 或者 clearTimeout。 4 闭包 在闭包中引入闭包外部的变量时，当闭包结束时，此对象无法被垃圾回收（GC） 闭包可以维持函数内局部变量，使其得不到释放。例子： 123456var a &#x3D; function() &#123; var largeStr &#x3D; new Array(1000000).join(&#39;x&#39;); return function() &#123; return largeStr; &#125;&#125;(); 5 自动类型装箱12var s &#x3D; &quot;test test&quot;;alert(s.length); s 本身是一个 string 而非 object，它没有 length 属性，所以当访问 length 时，JS 引擎会自动创建一个临时 String 对象封装 s，而这个对象一定会泄漏。这个 bug 匪夷所思，所幸解决起来相当容易，记得所有值类型做.运算之前先显示转换一下： 123var s &#x3D; &quot;test test&quot;;alert(new String(s).length); 确保不会内存泄漏在游戏开发中，需要尽量避免内存泄漏的可能性，作为开发者，在编码过程中至少应当注意： 对于不需要使用的数据，将其置为null，来“解除引用”。注意：解除一个值的引用不代表它会立刻被垃圾回收期回收内存，而是在下一个垃圾回收周期的时候，垃圾回收期能知道这个值是可以被回收的。 清空数组时建议的做法是array.length = 0,而不是array = []，因为这种写法会创建新的数组去覆盖原来的数组。 用完的setTimeout和setInterval一定要记得clearTimeout和clearInterval，避免内存泄漏。 其他垃圾回收机制的触发时间 什么时候触发垃圾回收？ 垃圾回收周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6 的垃圾回收是根据内存分配量运行的，当环境中存在 256 个变量、4096 个对象、64K 的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好嘛？但是如果环境中就是有这么多变量一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法玩了。 微软在 IE7 中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，如果垃圾回收器回收的内存分配量低于程序占用内存的 15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临界条件翻倍，如果回收的内存高于 85%，说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作智能了很多。 合理的 GC 方案 JavaScript 引擎基础 GC 方案是（simple GC）：mark and sweep（标记清除），即：遍历所有可访问的对象。回收已不可访问的对象。 GC 的缺陷和其他语言一样，JavaScript 的 GC 策略也无法避免一个问题：GC 时，停止响应其他操作，这是为了安全考虑。而 JavaScript 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免 GC 造成的长时间停止响应（造成卡顿）。 摘录、总结内容来自于\u001d微信公众号/知乎/Google如有侵权，请联系删除，谢谢！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.extingstudio.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.extingstudio.com/tags/JavaScript/"}]},{"title":"JavaScript深入浅出之理解Null和Undefined","slug":"2019-11-20-Difference-between-Null-and-Undefined","date":"2019-11-18T16:00:00.000Z","updated":"2020-08-25T07:41:52.690Z","comments":true,"path":"2019/11/19/2019-11-20-Difference-between-Null-and-Undefined/","link":"","permalink":"https://www.extingstudio.com/2019/11/19/2019-11-20-Difference-between-Null-and-Undefined/","excerpt":"","text":"前言在JavaScript有5个基本的简单数据类型：Number，String，Boolean，Null，Undefined 和一个复杂数据类型Object，其中Null和Undefined是最特殊的两个，在开发中经常会被搞混。 为什么在JavaScript中会需要Null和Undefined两个值来表示“无”在JavaScript中，某些情况下null和undefined是相等的。例如： 12345678910if (!undefined) console.log(&#39;undefined is false&#39;);&#x2F;&#x2F; undefined is falseif (!null) console.log(&#39;null is false&#39;);&#x2F;&#x2F; null is falseundefined &#x3D;&#x3D; null&#x2F;&#x2F; true null和undefined的区别null表示“没有对象”，即该处不应该有值： 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。 12Object.getPrototypeOf(Object.prototype)&#x2F;&#x2F; null undefined表示“缺少值”，就是此处应该有一个值，但是还没有定义： 变量被声明了，但还没有赋值，就等于undefined。 调用函数的时候，本应提供的参数没有提供，该参数就为undefined。 一个对象没有赋值的属性，该属性的值就位undefined。 函数没有return返回值时，默认返回undefined。 例子： 123456789101112var i; i // undefinedfunction f(x)&#123; console.log(x)&#125;f() // undefinedvar o = new Object();o.p // undefinedvar x = f();x // undefined 如何判断一个变量是否为null或undefinedundefined判断如何判断一个变量是否为undefined，有两个方法： 使用严格相等操作符 === 或 严格不相等操作符 ！== ，因为标准相等操作符 == 还会检查变量是否为null，为null的时候也会返回true。 使用 typeof 操作符，对于未定义的变量只能使用这种方法判断，否则会报错。 注意由于undefined未被JS设置为保留关键字，因此在代码中将变量名取为undefined是不会报错的，因此当undefined作为变量被重写了之后，用上面的判断方法就会失效（虽然正常情况下应该不会有开发者这样做。。。），例如： 1234var undefined &#x3D; 1;if(1 &#x3D;&#x3D;&#x3D; undefined)&#123; &#x2F;&#x2F; true &#x2F;&#x2F;do something&#125; 确保万无一失的方法是使用void操作符： The void operator evaluates the given expression and then returns undefined. void 运算符 对给定的表达式进行求值，然后返回 undefined 12var data;console.log(data &#x3D;&#x3D;&#x3D; void 0); &#x2F;&#x2F;true null判断当使用typeof null的时候，返回值会是一个“object”，从逻辑角度来看，null值表示一个空对象指针，它代表的其实就是一个空对象，所以使用typeof操作符检测时返回”object”也是可以理解的： 12var data &#x3D; null;console.log(typeof data); &#x2F;&#x2F; &quot;object&quot; 正确的判断方法是使用严格相等操作符 === ： 123if(data === null)&#123; // true console.log(&quot;data中没有保存对象引用！&quot;); &#125; null和undefined的不同用法null的用法 当声明一个即将保存对象的变量，但还没有赋值时，应当初始化为null； 当一个对象不再使用的时候，应该赋值为null，以“解除引用”，以便垃圾回收器，在下一个垃圾回收周期回收这个对象（并不会立即释放对象所占的内存）； 引用转载来源阮一峰-undefined与null的区别JavaScript深入理解之undefined与null","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.extingstudio.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.extingstudio.com/tags/JavaScript/"}]},{"title":"分离歌曲音频中的人声和背景音乐","slug":"2019-11-06-Seprate-Audio-Voice-By-Spleeter","date":"2019-11-05T16:00:00.000Z","updated":"2020-08-25T07:41:39.140Z","comments":true,"path":"2019/11/06/2019-11-06-Seprate-Audio-Voice-By-Spleeter/","link":"","permalink":"https://www.extingstudio.com/2019/11/06/2019-11-06-Seprate-Audio-Voice-By-Spleeter/","excerpt":"","text":"从一首歌中分离人声和BGM(背景音乐) 介绍想要K歌却苦于找不到喜欢的音乐的纯BGM？想要去除歌曲中的各种乐器的背景音乐，来个清唱版？不如试试这个开源项目吧 来自法国的音乐流媒体公司 Deezer 开源了一个音轨分离软件 spleeter，只需输入一段命令就可以将音乐的人声和各种乐器声分离，支持 mp3、wav、ogg 等常见音频格式。 这款软件基于 TensorFlow 开发，效果拔群，有网友说自己曾经试过无数类似软件，spleeter 是最好用的一个。 我在配置好环境后，测试了一下，效果拔群，几乎是我使用过的最好的分离人声和消除背景音的工具。我使用的测试歌曲是米津玄师的《Lemon》 点击蓝字播放↓转换前：原声转换后的人声部分：人声MP3转换后的背景音乐部分：背景音MP3 虽然网页上的音频经过了压缩，音质不太好，但是可以很明显的感受到，分离的效果是非常明显的，人声的音频几乎听不到BGM了，BGM的音频也只能听到一点点的不和谐。 spleeter 还支持 GPU 加速。如果在 GPU 上运行，会比实时分解速度快 100 倍，也就是说分解一首 5 分钟的歌曲只需要 3 秒。即使是使用CPU，分解这样一首4分钟的音频，也只用了不到1分钟的时间，个人使用上来说过绝对足够了。 GitHub项目地址：Spleeter人声分离 使用方法环境配置操作系统： Mac OS / Windows / LinuxPython： Version3.7 / Version 2.7Conda： Miniconda 步骤 安装Conda环境 从GitHub上Clone项目到本地 使用Conda命令运行Spleeter完成人声音频分离 详细安装步骤 这里只以MacOS为例，Windows的步骤大同小异，有问题可以留言。 在Conda的官网上下载自己计算机对应版本的Conda安装程序，或者包管理器进行安装，Conda官网地址点击这里Conda，或者点击这里的下载页进行下载：Miniconda下载地址 如下图，点击蓝字进行下载，32位的系统就下载32位的，64位的就下载64位的，Mac OS系统的直接下载.pkg文件就行。由于是国外的官网，可能下载会中断，耐心多下载几次即可，是在无法下载的可以在本文下面留言邮箱地址，我看到会把安装包发到你的邮箱📮里。 下载完成后，点击安装 如果遇到未信任的程序，无法安装，请到系统偏好设置-&gt;安全与隐私-&gt;允许从以下位置下载应用勾选AppStore和被认可的开发者 安装完成后，打开命令行工具iTerm，在命令行中输入：conda -V,如果输出不是command not found，那么Conda环境就安装成功了 如果本机有git，那么直接输入 git clone https://github.com/deezer/spleeter 克隆git仓库到本地，没有安装git的话点击：Spleeter人声分离，点击DownloadZIP，下载到本地 5.进入项目所在的文件夹，打开命令行，在命令行中输入命令： conda env create -f spleeter/conda/spleeter-cpu.yaml 按回车后，再输入命令 conda activate spleeter-cpu 如果想换成 GPU 环境，只需将上述代码中的 spleeter-cpu 换成 spleeter-gpu。 最后再输入：spleeter separate -i audio_example.mp3 -o audio_output -p spleeter:4stems 在分离音轨的命令中，加入选项 - p spleeter:4stems 来指定音轨数量，如果不加，系统默认分离为 2 个音轨。 最终乐器和人声将以 wav 文件的格式保存在 audio_output 文件夹中。分离过程可以在 GPU 或 CPU 上执行。在 GPU 上运行，速度非常快，可以实现 100 倍的加速。","categories":[{"name":"工具","slug":"工具","permalink":"https://www.extingstudio.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://www.extingstudio.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"洗牌算法/Fisher-Yates Shuffle","slug":"2019-09-20-Fisher-Yates -Shuffle","date":"2019-09-19T16:00:00.000Z","updated":"2020-08-25T07:41:30.985Z","comments":true,"path":"2019/09/20/2019-09-20-Fisher-Yates -Shuffle/","link":"","permalink":"https://www.extingstudio.com/2019/09/20/2019-09-20-Fisher-Yates%20-Shuffle/","excerpt":"","text":"洗牌算法/Fisher-Yates Shuffle洗牌算法在游戏开发中，经常会遇到需要将一个数组打乱的情况，例如，在一个卡牌系统中需要做一个抽卡，给你8张卡牌，从中抽取一张，并获得奖励：使用洗牌算法打乱卡牌中的奖励，实现随机抽奖的效果： Fisher-Yates Shuffle算法费舍尔·耶茨洗牌算法的做法是：给出数组Array，数组长度为n，取数组最后一个值M，再从数组的前n-1个元素中随机取一个值N，与最后一个值交换位置M，再取数组倒数第二个值N1，在前n-2各元素中随机取一个值M1与N1交换位置，依次取完剩下的值，完成数组打乱，算法的时间复杂度为O(n)。JS实现： 12345let arr &#x3D; [0, 1, 2, 3, 4];for(let i &#x3D; 0; i&lt; arr.length;i++)&#123; const random &#x3D; Math.floor(Math.random() * (i+1)); [arr[i], arr[random]] &#x3D; [arr[random], arr[i]];&#125; 简单的打乱算法还有另一种简单的随机打乱算法，虽然也可以实现随机打乱数组，但是在大量的结果上并不能实现完全的随机，原因是JS源码中的sort()方法： v8 在处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于10时，使用插入排序；反之，使用快排。 其实不管用什么排序方法，大多数排序算法的时间复杂度介于 O(n) 到 O(n2) 之间，元素之间的比较次数通常情况下要远小于 n(n-1)/2，也就意味着有一些元素之间根本就没机会相比较（也就没有了随机交换的可能），这些 sort 随机排序的算法自然也不能真正随机。 通俗的说，其实我们使用 array.sort 进行乱序，理想的方案或者说纯乱序的方案是：数组中每两个元素都要进行比较，这个比较有 50% 的交换位置概率。如此一来，总共比较次数一定为 n(n-1)。而在 sort 排序算法中，大多数情况都不会满足这样的条件。因而当然不是完全随机的结果了。JS实现： 12const arr &#x3D; [0, 1, 2, 3, 4];arr.sort(() &#x3D;&gt; Math.random() &gt; 0.5);","categories":[{"name":"算法","slug":"算法","permalink":"https://www.extingstudio.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.extingstudio.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"工作中最常用的Git命令及常见错误解决方案","slug":"2019-09-10-The_Most Commonly_Used_Git_Command_At_Work","date":"2019-09-09T16:00:00.000Z","updated":"2020-08-25T07:41:18.518Z","comments":true,"path":"2019/09/10/2019-09-10-The_Most Commonly_Used_Git_Command_At_Work/","link":"","permalink":"https://www.extingstudio.com/2019/09/10/2019-09-10-The_Most%20Commonly_Used_Git_Command_At_Work/","excerpt":"","text":"Git主要操作命令1. git clone 克隆远程代码仓库2. git pull / git pull –rebase 拉取远程代码库到本地3. git rebase –continue 如果git pull后与本地修改有冲突，需要先解决冲突，并在Source Tree中将冲突标记为与解决，使用git rebase --continue合并冲突4. git commit -m’xxx’ 提交修改到本地5. git push origin master/[branch] 推送本地修改到远端库 推荐一个学习Git命令的网站：Learn Git Branching,这个是网站的首页： 在这个网站的沙盒中可以使用各种Git命令去熟悉Git命令的作用和使用方法而不不担心损坏自己电脑中的文件。 并且可以通过动画的方式去理解Git中的各种合并，分支等操作。 Git 常用命令 git status 查看当前本地库状态 git log 查看最近的commit记录 git branch 查看当前分支 Git 常见误操作及解决方式** 1. 多个分支一起开发的时候将A分支的改动错误的提交到B的场景：** 123456789101112131415161718192021222324252627将该分支的本不应该提交的commit撤销git reset HEAD^按需选择想要回到哪个版本回到HEADgit reset --soft HEAD回到HEAD的前一个版本git reset --soft HEAD^回到HEAD的前10个版本git reset --soft HEAD~5 利用id回到指定版本git reset --soft a06ef2f将撤销的代码暂存起来git stash切换到正确的分支git checkout feat&#x2F;xxx重新应用缓存 git stash pop在正确的分支进行提交操作git add . &amp;&amp; git commit -m &quot;update xxxx&quot; Git只提交部分修改的文件（提交指定文件）在我们的项目中，经常会在本地编译一些代码，还未写完，测试那边来告诉你要改改某个文件的bug，非常着急，此时改完了，提交的时候，自己还在编译的代码并不想提交，此时，你可以利用git这些指令帮助你！ 1/ git status -s 查看仓库状态 2/ git add src/components/文件名 添加需要提交的文件名（加路径–参考git status 打印出来的文件路径） 3/ git stash -u -k 忽略其他文件，把现修改的隐藏起来，这样提交的时候就不会提交未被add的文件 4/ git commit -m “哪里做了修改可写入…” 5/ git pull 拉取合并 6/ git push 推送到远程仓库 7/ git stash pop 恢复之前忽略的文件（非常重要的一步） Git 清除本地未跟踪的文件和目录有时候我们在打包之后引擎会自动生成一些多余的文件，这些文件不需要提交到远程库中，虽然可以通过 .gitignore添加忽略列表，但是，有时候这样做并不方便。可以使用命令 git clean: git clean 命令支持以下参数： 123git clean [-d] [-f] [- ] [-n] [-q] [-e ] [-x | -X] [--] ... 其中几个主要参数用法如下： 123456-d # 删除未跟踪目录以及目录下的文件，如果目录下包含其他git仓库文件，并不会删除（-dff可以删除）。-f # 如果 git cofig 下的 clean.requireForce 为true，那么clean操作需要-f(--force)来强制执行。- # 进入交互模式-n # 查看将要被删除的文件，并不实际删除文件 通过以上几根参数组合，基本上可以满足删除未跟踪文件的需求了。例如在删除前先查看有哪些文件将被删除运行： 123git clean -n 想删除当前工作目录下的未跟踪文件，但不删除文件夹运行（如果 clean.requireForce 为 false 可以不加 -f 选项）： 123git clean -f 想删除当前工作目录下的未跟踪文件以及文件夹运行： 1git clean -df","categories":[{"name":"Git","slug":"Git","permalink":"https://www.extingstudio.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.extingstudio.com/tags/Git/"}]},{"title":"Mac常用软件工具合集（更新中...）","slug":"2018-11-06-Mac_Most_Used_Software","date":"2018-11-05T16:00:00.000Z","updated":"2020-08-25T07:41:10.807Z","comments":true,"path":"2018/11/06/2018-11-06-Mac_Most_Used_Software/","link":"","permalink":"https://www.extingstudio.com/2018/11/06/2018-11-06-Mac_Most_Used_Software/","excerpt":"","text":"&emsp; 1. 软件列表&emsp; 工具 PDFelement 6 Pro (付费) 滴答清单 微小宝公众号版 Alfred 3 Archiver Background Music Backgrounds BetterTouchTool CleanMyMac X (付费) iStat Menus KCNScrew NewFileMenu Parallels Desktop TeamViewer (免费) Tuxera Disk Manager (付费) iMazing (付费) Rotato for mac(3D样机宣传视频制作软件) &emsp; 网络 ShadowsocksX-NG-R8 (免费) Coherence Pro (付费) Google Chrome Lonlife &emsp; 开发 Unity (免费) 微信开发者工具 blender CocosCreator Dash LayaAirIDE Rhinoceros Smaller Sourcetree TexturePacker Tiled Visual Studio Code Visual Studio Xcode Beyond Compare &emsp; 编辑器 印象笔记 (免费) Atom Sublime Text Microsoft Excel Microsoft PowerPoint Microsoft Word MWeb (付费) Notability (付费) PDFelement Express Ulysses &emsp; 阅读 Reeder (免费) Medium &emsp; 媒体 Adobe After Effects CC 2018 (付费) Adobe Audition CC 2018 (付费) Adobe Lightroom CC 2018 (付费) Adobe Media Encoder CC 2018 Adobe Photoshop CC 2018 Adobe Premiere Pro CC 2018 Final Cut Pro 网易云音乐 (免费) 迅雷影音 LICEcap OBS Permute PicGo Sketch &emsp; 下载 JDownloader2 (免费) 迅雷 2 Aria2GUI &emsp; 常用插件 WeChatPlugin-MacOS baidu-dl Full Page Screen Capture Tampermonkey Google 翻译 Pixlr Today 书签侧边栏 迅雷下载支持 Cocos Creator Inspector 页面自动刷新插件 &emsp; 游戏 多宝 (免费游戏平台) 英雄联盟 Call of Duty 4 - Modern Warfare Dont Starve Epic Games Launcher Leo’s Fortune Poly Bridge Steam This War of Mine &emsp;&emsp;&emsp; 软件介绍工具 PDFelement 6 Pro (付费) 用来阅读，编辑PDF文件，重点功能是可以直接编辑PDF文档，在别人分享，或者已经生成好的PDF文档中，修改文字和图片，还可以进行PDF签名。 滴答清单 待办事项提醒工具，提供了Wedget。 微小宝公众号版 管理公众号，可以同时登录多个公众号进行管理，查看粉丝数据，消息群发，统计图文消息。 Alfred 3 (下载地址) Mac上的效率神器，提供全局搜索，高效率快捷键，堪比Mac上的 捷径 Archiver(下载地址) Mac上较好用的解压工具，解压速度很快，解压缩的文件类型最全面，并且支持在Finder中点击右键解压缩，强力推荐。 Background Music 神器！用于在Mac上设置不同app的音乐大小，在用过Windows后，再使用Mac的用户会有一个很大的不习惯的地方，就是Mac无法像Windows一样分别去改变不同app的音量大小，但是，在安装了这款小巧的APP之后，就可以在状态栏分别设置不同APP的音量大小了，并且可以设置开机启动，非常方便，也不会占用太大的内存。 Backgrounds (下载地址) 用于在Mac上设置动态壁纸，性能占用较小，可以使用自己下载的视频/gif/电影等作为动态壁纸。 BetterTouchTool 触控板增强工具 CleanMyMac X(暂无用永久免费的下载地址，可以留言邮箱，发到你的邮箱中) Mac系统清理工具，虽说Mac不像Windows需要时常清理，但是用时间长了，系统缓存，软件卸载留存文件等，会越来越多，并且Mac的硬盘空间“寸土寸金”，有一款能方便快捷，智能的清理出一些硬盘空间还是必要的，在用过许多的清理助手和看过评价后，这款是比较简洁好用的，推荐。 iStat Menus 一款用于在Mac状态栏上实时查看网络上传下载速度，电脑运行温度的软件，虽然它还有，调节电脑风扇转速，查看硬盘状态，内存状态等等便捷功能，但我主要是用来查看网络状态，习惯了Windows上可以通过360，腾讯管家等实时查看网速的功能，这款小软件是非常好用的。 KCNScrew 软件序列号搜索工具，能搜到一些付费软件的序列号，太新的软件版本搜不到，老版本可以查得到。 NewFileMenu 用于在Finder中右键点击能直接新建文件的工具，类似Windows中在文件夹中新建右键文件，例如新建tet,word,ppt,excel等文件。 Parallels Desktop Mac系统上最强大的虚拟机，可以在Mac上高性能运行Windows，Linux等系统，用来运行一些Windows独有的软件，游戏等都没有问题。强烈推荐。 TeamView一款远程控制软件，支持Windows，Mac，iOS, Android多平台。 Tuxera Disk Manager (付费) 用于在Mac系统上读取的磁盘格式是NTFS(Windows系统文件格式)的硬盘。由于NTFS是Windows独有的文件格式，而Mac系统屏蔽了此格式的写入，只能通过另外的软件来读写。也可以通过将磁盘格式化为FAT32格式的文件格式，可以同时在Mac和Windows中读写文件，但是FAT32格式的文件系统并不支持单个文件大于4GB的存储，所以对于有大文件存储需求的用户来说，Tuxera Disk Manager是最好的选择。 iMazing Mac上比iTunes更好用的iPhone管理工具，可以用来备份，管理iPhone的照片，视频，文件等。 Rotato for mac(3D样机宣传视频制作软件)如图所示的3D样机展示工具，下载地址：Mac下载-Rotato![Roato Demo](https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/Rotato Snapshot1.png) 网络 ShadowsocksX-NG-R8 (免费) (下载地址) Mac上的梯(fan)子(qiang)工具，需要自行购买或者查找免费的SS账号，可以定于服务器节点，设定全局或者配置代理模式。技术开发者必备。 Coherence Pro (付费) 暂无 Google Chrome (下载地址) 最好用的浏览器，前端开发者必备。 Lonlife (下载地址) 玲珑加速器，外服游戏加速器，延迟低，效果好，售后服务好，需要付费购买账户，不过有免费试用时间。 开发1.Beyond Compare Beyond Compare 是一款强大专业的文件和文件夹对比工具。使用它可以很方便地比较出两个文件或文件夹的差异，相差的每一个字节用颜色加以标识，让您查看方便，支持众多种格式的对比。只需使用简单操作方式方可开启快捷省事的文件对比体验，找出您所需差异、合并变化，然后同步文件，并生成报告一气呵成。打开软件后的主界面： 当我们需要对比两个文件夹的内容时，显示如下界面：把我们需要对比的两个文件夹分别拖入左右两边，点击文件夹对比，双击文件夹可以展开文件夹，双击文件可以进入文件，查看文件内容，并进行左右文件的对比：其中 红色 和 灰色显示的左右相同的部分，紫色文字的显示的左右不同的部分； 点击上方状态栏的差别 和 相同，可以分别查看对比的两个文件的有差别和相同的部分。 编辑器 印象笔记 (免费) 笔记软件，需要付费账户才能使用全部高级功能。 Atom GitHub自家推出的极简笔记软件，我心目中最好用的文本编辑器，用来做日常的记录，项目记录管理非常合适。支持语法高亮，git嵌入，各种插件支持。(其实他只是个文本编辑器) Sublime Text 文本编辑器，主要用来写前端代码。 Microsoft Excel 制作Excel表格 Microsoft PowerPoint 制作PPT文档 Microsoft Word 制作Word文件 MWeb (付费) 我挑选的最好用的MarkDown文本编辑器，支持Markdown语法格式，实时预览，iCloud同步。这篇文章就是用这个MWeb 编辑的Markdown文本。 Notability (付费) 笔记软件。 Ulysses 简单的文本编辑器。 常用插件 WeChatPlugin-MacOS (下载地址) 功能 消息自动回复 消息防撤回 远程控制(已支持语音) 微信多开 第二次登录免认证 聊天置底功能(类似置顶) 微信窗口置顶 会话多选删除 自动登录开关 通知中心快捷回复 聊天窗口表情包复制 &amp; 存储 小助手检测更新提醒 alfred 快捷发送消息 &amp; 打开窗口 (需安装：wechat-alfred-workflow) 会话一键已读 一键清除空会话 支持国际化 新增一键更新 新增关于小助手 去除微信url转链（从此直接打开抖音链接🌝 史上最强 alfred 扩展🌚 新增移除会话(不删除聊天记录) 远程控制： 屏幕保护 清空废纸篓 锁屏、休眠、关机、重启 退出QQ、WeChat、Chrome、Safari、所有程序 网易云音乐(播放、暂停、下一首、上一首、喜欢、取消喜欢) 小助手(获取指令、防撤回开关、自动回复开关、免认证登录开关)&emsp; baidu-dl (下载地址：Chrome插件商店) 功能：获取百度云的下载直链，可以通过浏览器直接下载百度云文件，而无需下载百度云网盘； &emsp; Full Page Screen Capture (下载地址：Chrome插件商店) 功能：截取浏览器网页页面长截图，方便保存网页信息，和分享； &emsp; Tampermonkey (下载地址：Chrome插件商店) 功能：Chrome插件中心，包含海量免费Chrome插件 &emsp; Google 翻译 (下载地址:Chrome插件商店) 功能：双击单词翻译，划线网页文字翻译 &emsp; Pixlr Today （下载地址：Chrome插件商店） 功能：简约好看的Chrome主页 &emsp; 书签侧边栏 (下载地址：Chrome插件商店) 功能：扩展Chrome侧边栏书签 &emsp; 迅雷下载支持（下载地址：Chrome插件商店） 功能：Everything download by 迅雷 &emsp; Cocos Creator Inspector （GitHub下载） 功能：Cocos开发插件 &emsp; 页面自动刷新插件 （下载地址：Chrome插件商店）功能：自动刷新页面，抢票神器，刷页面访问量神器&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 持续不定期更新中…","categories":[{"name":"软件","slug":"软件","permalink":"https://www.extingstudio.com/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"Mac","slug":"软件/Mac","permalink":"https://www.extingstudio.com/categories/%E8%BD%AF%E4%BB%B6/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://www.extingstudio.com/tags/Mac/"}]},{"title":"LeetCode_001 两数之和","slug":"2018-09-14-LeetCode_Practice_001","date":"2018-09-10T16:00:00.000Z","updated":"2020-08-25T07:40:51.511Z","comments":true,"path":"2018/09/11/2018-09-14-LeetCode_Practice_001/","link":"","permalink":"https://www.extingstudio.com/2018/09/11/2018-09-14-LeetCode_Practice_001/","excerpt":"","text":"1. 两数之和给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例： 123给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 测试用例： 输入：[2,7,11,15] ，9输出：[0，1] JavaScript： 1234567891011121314151617181920&#x2F;** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; *&#x2F;var twoSum &#x3D; function(nums, target) &#123; let array &#x3D; []; for(let &#x3D; 0 ; &lt; nums.length; ++)&#123; for(let j &#x3D; 0;j&lt;nums.length;j++)&#123; if( !&#x3D; j)&#123; if(nums[ ]+nums[j] &#x3D;&#x3D; target)&#123; array.push( ); array.push(j); return array; &#125; &#125; &#125; &#125; &#125;; 记录一下LeetCode刷题练习","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.extingstudio.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.extingstudio.com/tags/LeetCode/"}]},{"title":"工作中常用到的ES6语法","slug":"2018-09-10-ES6_Syntax_Commonly_Used_in_Work","date":"2018-09-10T16:00:00.000Z","updated":"2020-08-25T07:40:26.640Z","comments":true,"path":"2018/09/11/2018-09-10-ES6_Syntax_Commonly_Used_in_Work/","link":"","permalink":"https://www.extingstudio.com/2018/09/11/2018-09-10-ES6_Syntax_Commonly_Used_in_Work/","excerpt":"","text":"一、let和const在JavaScript中咱们以前主要用关键var来定义变量，ES6之后，新增了定义变量的两个关键字，分别是let和const。对于变量来说，在ES5中var定义的变量会提升到作用域中所有的函数与语句前面，而ES6中let定义的变量则不会，let声明的变量会在其相应的代码块中建立一个暂时性死区，直至变量被声明。let和const都能够声明块级作用域，用法和var是类似的，let的特点是不会变量提升，而是被锁在当前块中。 一个非常简单的例子： 123456789101112131415function test() &#123;if(true) &#123; console.log(a)&#x2F;&#x2F;TDZ，俗称临时死区，用来描述变量不提升的现象 let a &#x3D; 1&#125;&#125;test() &#x2F;&#x2F; a is not definedfunction test() &#123; if(true) &#123; let a &#x3D; 1 &#125; console.log(a)&#125; test() &#x2F;&#x2F; a is not defined 唯一正确的使用方法：先声明，再访问。 1234567function test() &#123; if(true) &#123; let a &#x3D; 1 console.log(a) &#125;&#125;test() &#x2F;&#x2F; 1 const声明常量，一旦声明，不可更改，而且常量必须初始化赋值。const虽然是常量，不允许修改默认赋值，但如果定义的是对象Object，那么可以修改对象内部的属性值。 12345const type &#x3D; &#123; a: 1&#125;type.a &#x3D; 2 &#x2F;&#x2F;没有直接修改type的值，而是修改type.a的属性值，这是允许的。console.log(type) &#x2F;&#x2F; &#123;a: 2&#125; const和let的异同点相同点：const和let都是在当前块内有效，执行到块外会被销毁，也不存在变量提升（TDZ），不能重复声明。不同点：const不能再赋值，let声明的变量可以重复赋值。const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 块级作用域的使用场景除了上面提到的常用声明方式，我们还可以在循环中使用，最出名的一道面试题：循环中定时器闭包的考题在for循环中使用var声明的循环变量，会跳出循环体污染当前的函数。 1234567891011121314for(var &#x3D; 0; &lt; 5; ++) &#123; setTimeout(() &#x3D;&gt; &#123; console.log() &#x2F;&#x2F;5, 5, 5, 5, 5 &#125;, 0)&#125;console.log() &#x2F;&#x2F;5 跳出循环体污染外部函数&#x2F;&#x2F;将var改成let之后for(let &#x3D; 0; &lt; 5; ++) &#123; setTimeout(() &#x3D;&gt; &#123; console.log() &#x2F;&#x2F; 0,1,2,3,4 &#125;, 0)&#125;console.log()&#x2F;&#x2F;i is not defined 无法污染外部函数在实际开发中，我们选择使用var、let还是const，取决于我们的变量是不是需要更新，通常我们希望变量保证不被恶意修改，而使用大量的const。使用const声明，声明一个对象的时候，也推荐使用const，当你需要修改声明的变量值时，使用let，var能用的场景都可以使用let替代。 symbolES6 以前，我们知道5种基本数据类型分别是Undefined，Null，Boolean，Number以及String，然后加上一种引用类型Object构成了JavaScript中所有的数据类型，但是ES6出来之后，新增了一种数据类型，名叫symbol，像它的名字表露的一样，意味着独一无二，意思是每个 Symbol类型都是独一无二的，不与其它 Symbol 重复。可以通过调用 Symbol() 方法将创建一个新的 Symbol 类型的值，这个值独一无二，不与任何值相等。 12var mySymbol&#x3D;Symbol();console.log(typeof mySymbol) &#x2F;&#x2F;&quot;symbol&quot; 二、字符串ES6字符串新增的方法UTF-16码位：ES6强制使用UTF-16字符串编码。关于UTF-16的解释请自行百度了解。 **codePointAt()**：该方法支持UTF-16，接受编码单元的位置而非字符串位置作为参数，返回与字符串中给定位置对应的码位，即一个整数值。 **String.fromCodePoiont()**：作用与codePointAt相反，检索字符串中某个字符的码位，也可以根据指定的码位生成一个字符。 **normalize()**：提供Unicode的标准形式，接受一个可选的字符串参数，指明应用某种Unicode标准形式。 在ES6中，新增了3个新方法。每个方法都接收2个参数，需要检测的子字符串，以及开始匹配的索引位置。 模板字符串字符串是JavaScript中基本类型之一，应该算是除了对象之外是使用最为频繁的类型吧，字符串中包含了例如substr，replace，indexOf,slice等等诸多方法，ES6引入了模板字符串的特性，用反引号来表示，可以表示多行字符串以及做到文本插值（利用模板占位符）。 123456789101112&#x2F;&#x2F; 以前的多行字符串我们这么写：console.log(&quot;hello world 1\\n\\hello cala&quot;);&#x2F;&#x2F; &quot;hello world&#x2F;&#x2F; hello cala&quot;&#x2F;&#x2F;有了模板字符串之后console.log(&#96;hello worldstring text line 2&#96;);&#x2F;&#x2F; &quot;hello world&#x2F;&#x2F; hello cala&quot; 可以用$&#123;&#125;来表示模板占位符，可以将你已经定义好的变量传进括弧中，例如： 1234567891011var name&#x3D;&quot;cala&quot;;var age&#x3D;22;console.log(&#96;hello,I&#39;am $&#123;name&#125;,my age is $&#123;age&#125;&#96;)&#x2F;&#x2F;hello,I&#39;am cala,my age is 22includes(str, index)：如果在字符串中检测到指定文本，返回true，否则false。let t &#x3D; &#39;abcdefg&#39;if(t.includes(&#39;cde&#39;)) &#123; console.log(2)&#125;&#x2F;&#x2F;true **startsWith(str, index)**：如果在字符串起始部分检测到指定文本，返回true，否则返回false。 123456789101112let t &#x3D; &#39;abcdefg&#39;if(t.startsWith(&#39;ab&#39;)) &#123; console.log(2)&#125;&#x2F;&#x2F;trueendsWith(str, index)：如果在字符串的结束部分检测到指定文本，返回true，否则返回false。let t &#x3D; &#39;abcdefg&#39;if(t.endsWith(&#39;fg&#39;)) &#123; console.log(2)&#125;&#x2F;&#x2F;true 如果你只是需要匹配字符串中是否包含某子字符串，那么推荐使用新增的方法，如果需要找到匹配字符串的位置，使用indexOf()。 三、函数函数的默认参数在ES5中，我们给函数传参数，然后在函数体内设置默认值，如下面这种方式。 1234567891011function a(num, callback) &#123; num &#x3D; num || 6 callback &#x3D; callback || function (data) &#123;console.log(&#39;ES5: &#39;, data)&#125; callback(num * num)&#125;a() &#x2F;&#x2F;ES5: 36，不传参输出默认值&#x2F;&#x2F;你还可以这样使用callbacka(10, function(data) &#123; console.log(data * 10) &#x2F;&#x2F; 1000， 传参输出新数值&#125;) 在ES6中，我们使用新的默认值写法 12345678910function a(num &#x3D; 6, callback &#x3D; function (data) &#123;console.log(&#39;ES6: &#39;, data)&#125;) &#123; callback(num * num)&#125;a() &#x2F;&#x2F;ES6: 36， 不传参输出默认值a(10, function(data) &#123; console.log(data * 10) &#x2F;&#x2F; 1000，传参输出新数值&#125;) 四、箭头函数（=&gt;）1234const arr &#x3D; [5, 10]const s &#x3D; arr.reduce((sum, item) &#x3D;&gt; sum + item)console.log(s) &#x2F;&#x2F; 15 箭头函数中this的使用跟普通函数也不一样，在JavaScript的普通函数中，都会有一个自己的this值，主要分为：普通函数： 函数作为全局函数被调用时，this指向全局对象 函数作为对象中的方法被调用时，this指向该对象 函数作为构造函数的时候，this指向构造函数new出来的新对象 还可以通过call，apply，bind改变this的指向 箭头函数： 箭头函数没有this，函数内部的this来自于父级最近的非箭头函数，并且不能改变this的指向。 箭头函数没有super 箭头函数没有arguments 箭头函数没有new.target绑定。 不能使用new 没有原型 不支持重复的命名参数。 箭头函数的简单理解1、箭头函数的左边表示输入的参数，右边表示输出的结果。12const s &#x3D; a &#x3D;&gt; aconsole.log(s(2)) &#x2F;&#x2F; 2 2、在箭头函数中，this属于词法作用域，直接由上下文确定，对于普通函数中指向不定的this，箭头函数中处理this无疑更加简单，如下：1234567891011121314151617&#x2F;&#x2F;ES5普通函数function Man()&#123; this.age&#x3D;22; return function()&#123; this.age+1; &#125;&#125;var cala&#x3D;new Man();console.log(cala())&#x2F;&#x2F;undefined&#x2F;&#x2F;ES6箭头函数function Man()&#123; this.age&#x3D;22; return () &#x3D;&gt; this.age+1;&#125;var cala&#x3D;new Man();console.log(cala())&#x2F;&#x2F;23 3、箭头函数中没有arguments(我们可以用rest参数替代),也没有原型，也不能使用new 关键字，例如：1234567891011121314&#x2F;&#x2F;没有argumentsvar foo&#x3D;(a,b)&#x3D;&gt;&#123;return arguments[0]*arguments[1]&#125;console.log(foo(3,5))&#x2F;&#x2F;arguments is not defined&#x2F;&#x2F;没有原型var Obj &#x3D; () &#x3D;&gt; &#123;&#125;;console.log(Obj.prototype); &#x2F;&#x2F; undefined&#x2F;&#x2F;不能使用new 关键字var Obj &#x3D; () &#x3D;&gt; &#123;&quot;hello world&quot;&#125;;var o &#x3D; new Obj(); &#x2F;&#x2F; TypeError: Obj is not a constructor 4、箭头函数给数组排序123const arr &#x3D; [10, 50, 30, 40, 20]const s &#x3D; arr.sort((a, b) &#x3D;&gt; a - b)console.log(s) &#x2F;&#x2F; [10,20,30,40,50] 尾调用优化尾调用是指在函数return的时候调用一个新的函数，由于尾调用的实现需要存储到内存中，在一个循环体中，如果存在函数的尾调用，你的内存可能爆满或溢出。 ES6中，引擎会帮你做好尾调用的优化工作，你不需要自己优化，但需要满足下面3个要求：1、函数不是闭包2、尾调用是函数最后一条语句3、尾调用结果作为函数返回 尾调用实际用途——递归函数优化在ES5时代，我们不推荐使用递归，因为递归会影响性能。但是有了尾调用优化之后，递归函数的性能有了提升。 123456789101112&#x2F;&#x2F;新型尾优化写法&quot;use strict&quot;; function a(n, p &#x3D; 1) &#123; if(n &lt;&#x3D; 1) &#123; return 1 * p &#125; let s &#x3D; n * p return a(n - 1, s)&#125;&#x2F;&#x2F;求 1 x 2 x 3的阶乘let sum &#x3D; a(3)console.log(sum) &#x2F;&#x2F; 6 五、ES6对象新增方法Object.assign()Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。String类型和 Symbol 类型的属性都会被拷贝。合并对象 1234567var o1 &#x3D; &#123; a: 1 &#125;;var o2 &#x3D; &#123; b: 2 &#125;;var o3 &#x3D; &#123; c: 3 &#125;;var obj &#x3D; Object.assign(o1, o2, o3);console.log(obj); &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。 合并具有相同属性的对象 12345var o1 &#x3D; &#123; a: 1, b: 1, c: 1 &#125;;var o2 &#x3D; &#123; b: 2, c: 2 &#125;;var o3 &#x3D; &#123; c: 3 &#125;;var obj &#x3D; Object.assign(&#123;&#125;, o1, o2, o3);console.log(obj); &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125; 六、Map和SetMap和Set都叫做集合，但是他们也有所不同。Set常被用来检查对象中是否存在某个键名，Map集合常被用来获取已存的信息。Set是有序列表，含有相互独立的非重复值。 Array和Set对比都是一个存储多值的容器，两者可以互相转换，但是在使用场景上有区别。如下: Array的indexOf方法比Set的has方法效率低下 Set不含有重复值（可以利用这个特性实现对一个数组的去重） Set通过delete方法删除某个值，而Array只能通过splice。两者的使用方便程度前者更优 Array的很多新方法map、filter、some、every等是Set没有的（但是通过两者可以互相转换来使用） Object和Map对比 Object是字符串-值，Map是值-值 Object键为string类型,Map的键是任意类型 手动计算Object尺寸,Map.size可以获取尺寸 Map的排序是插入顺序 Object有原型，所以映射中有一些缺省的键。可以理解为Map=Object.create(null) Set操作集合1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let set &#x3D; new Set()&#x2F;&#x2F; Set转化为数组let arr &#x3D; Array.from(set)let arr &#x3D; [...set]&#x2F;&#x2F; 实例属性（继承自Set）set.constructor &#x3D;&#x3D;&#x3D; Set set.size &#x2F;&#x2F; 操作方法set.add(1) &#x2F;&#x2F; 添加一个值set.delete(1) &#x2F;&#x2F;删除一个值set.has(1) &#x2F;&#x2F;判断是否有这个值（Array中的indexOf）set.clear() &#x2F;&#x2F;清除所有值&#x2F;&#x2F; 获取用于遍历的成员方法(Set的遍历顺序就是插入顺序)set.keys() &#x2F;&#x2F; 返回键名的遍历器set.values() &#x2F;&#x2F; 返回键值得遍历器set.entries() &#x2F;&#x2F; 返回键值对的遍历器set.forEach() &#x2F;&#x2F; 循环遍历每个值(和Array的方法一致)for (let key of set.keys())&#123;&#125;for (let val of set.values())&#123;&#125;for (let entry of set.entries())&#123;&#125;&#x2F;&#x2F; 使用数组方法来处理set值set &#x3D; new Set(arr)set &#x3D; new Set([...set].map((x) &#x3D;&gt; x &#x3D; x * 2))set &#x3D; new Set([...set].filter((x) &#x3D;&gt; x &gt; 2))Map的方法集合let map &#x3D; new Map()&#x2F;&#x2F; 实例属性(继承自Map)map.constructor &#x3D;&#x3D;&#x3D; Mapmap.size&#x2F;&#x2F; 操作方法map.set(1,2)map.get(1)map.delete(1)map.has(1)map.clear()&#x2F;&#x2F; 遍历方法map.keys()map.values()map.entries()map.forEach()&#x2F;&#x2F; Map和数组的转换map &#x3D; new Map([[&#39;key&#39;,&#39;val&#39;],[2,1]]) &#x2F;&#x2F; 要求双成员数组let arr &#x3D; [...map]&#x2F;&#x2F; 值得注意的是Map的键是跟内存绑定的map.set([1], &#39;s&#39;)map.get([1])let arr &#x3D; [1]let arr1 &#x3D; [1]map.set(arr, &#39;s&#39;)map.get(arr)map.set(arr1, &#39;s&#39;)map.get(arr1) 七、迭代器（Iterator）1. entries() 返回迭代器：返回键值对12345678910111213141516171819202122&#x2F;&#x2F;数组const arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];for(let v of arr.entries()) &#123; console.log(v)&#125;&#x2F;&#x2F; [0, &#39;a&#39;] [1, &#39;b&#39;] [2, &#39;c&#39;]&#x2F;&#x2F;Setconst arr &#x3D; new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);for(let v of arr.entries()) &#123; console.log(v)&#125;&#x2F;&#x2F; [&#39;a&#39;, &#39;a&#39;] [&#39;b&#39;, &#39;b&#39;] [&#39;c&#39;, &#39;c&#39;]&#x2F;&#x2F;Mapconst arr &#x3D; new Map();arr.set(&#39;a&#39;, &#39;a&#39;);arr.set(&#39;b&#39;, &#39;b&#39;);for(let v of arr.entries()) &#123; console.log(v)&#125;&#x2F;&#x2F; [&#39;a&#39;, &#39;a&#39;] [&#39;b&#39;, &#39;b&#39;] 2.values() 返回迭代器：返回键值对的value12345678910111213141516171819202122&#x2F;&#x2F;数组const arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];for(let v of arr.values()) &#123; console.log(v)&#125;&#x2F;&#x2F;&#39;a&#39; &#39;b&#39; &#39;c&#39;&#x2F;&#x2F;Setconst arr &#x3D; new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);for(let v of arr.values()) &#123; console.log(v)&#125;&#x2F;&#x2F; &#39;a&#39; &#39;b&#39; &#39;c&#39;&#x2F;&#x2F;Mapconst arr &#x3D; new Map();arr.set(&#39;a&#39;, &#39;a&#39;);arr.set(&#39;b&#39;, &#39;b&#39;);for(let v of arr.values()) &#123; console.log(v)&#125;&#x2F;&#x2F; &#39;a&#39; &#39;b&#39; 3.keys() 返回迭代器：返回键值对的key12345678910111213141516171819202122&#x2F;&#x2F;数组const arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];for(let v of arr.keys()) &#123; console.log(v)&#125;&#x2F;&#x2F; 0 1 2&#x2F;&#x2F;Setconst arr &#x3D; new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);for(let v of arr.keys()) &#123; console.log(v)&#125;&#x2F;&#x2F; &#39;a&#39; &#39;b&#39; &#39;c&#39;&#x2F;&#x2F;Mapconst arr &#x3D; new Map();arr.set(&#39;a&#39;, &#39;a&#39;);arr.set(&#39;b&#39;, &#39;b&#39;);for(let v of arr.keys()) &#123; console.log(v)&#125;&#x2F;&#x2F; &#39;a&#39; &#39;b&#39; 虽然上面列举了3种内建的迭代器方法，但是不同集合的类型还有自己默认的迭代器，在for of中，数组和Set的默认迭代器是values()，Map的默认迭代器是entries()。 for of循环解构 对象本身不支持迭代，但是我们可以自己添加一个生成器，返回一个key，value的迭代器，然后使用for of循环解构key和value。 12345678910111213const obj &#x3D; &#123; a: 1, b: 2, *[Symbol.iterator]() &#123; for(let in obj) &#123; yield [, obj[]] &#125; &#125;&#125;for(let [key, value] of obj) &#123; console.log(key, value)&#125;&#x2F;&#x2F; &#39;a&#39; 1, &#39;b&#39; 2 字符串迭代器 12345const str &#x3D; &#39;abc&#39;;for(let v of str) &#123; console.log(v)&#125;&#x2F;&#x2F; &#39;a&#39; &#39;b&#39; &#39;c&#39; ES6给数组添加了几个新方法：find()、findIndex()、fill()、copyWithin()**1.find()**：传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索。 12const arr &#x3D; [1, &quot;2&quot;, 3, 3, &quot;2&quot;]console.log(arr.find(n &#x3D;&gt; typeof n &#x3D;&#x3D;&#x3D; &quot;number&quot;)) &#x2F;&#x2F; 1 **2.findIndex()**：传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。 12const arr &#x3D; [1, &quot;2&quot;, 3, 3, &quot;2&quot;]console.log(arr.findIndex(n &#x3D;&gt; typeof n &#x3D;&#x3D;&#x3D; &quot;number&quot;)) &#x2F;&#x2F; 0 **3.fill()**：用新元素替换掉数组内的元素，可以指定替换下标范围。 1arr.fill(value, start, end) **4.copyWithin()**：选择数组的某个下标，从该位置开始复制数组元素，默认从0开始复制。也可以指定要复制的元素范围。 12345678910arr.copyWithin(target, start, end)const arr &#x3D; [1, 2, 3, 4, 5]console.log(arr.copyWithin(3)) &#x2F;&#x2F; [1,2,3,1,2] 从下标为3的元素开始，复制数组，所以4, 5被替换成1, 2const arr1 &#x3D; [1, 2, 3, 4, 5]console.log(arr1.copyWithin(3, 1)) &#x2F;&#x2F; [1,2,3,2,3] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，所以4, 5被替换成2, 3const arr2 &#x3D; [1, 2, 3, 4, 5]console.log(arr2.copyWithin(3, 1, 2)) &#x2F;&#x2F; [1,2,3,2,5] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，结束位置为2，所以4被替换成2 八、其他ES6中类class、Promise与异步编程、代理（Proxy）和反射（Reflection）API 转载自：学习ES6笔记──工作中常用到的ES6语法 原文链接：https://segmentfault.com/a/1190000016068235","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.extingstudio.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.extingstudio.com/tags/JavaScript/"}]},{"title":"关于Laya的中Timer的使用方法","slug":"2018-09-07-About_Use_of_Laya_Timer","date":"2018-09-06T16:00:00.000Z","updated":"2020-08-25T07:39:52.350Z","comments":true,"path":"2018/09/07/2018-09-07-About_Use_of_Laya_Timer/","link":"","permalink":"https://www.extingstudio.com/2018/09/07/2018-09-07-About_Use_of_Laya_Timer/","excerpt":"","text":"Laya中Timer的类1.官方文档 Laya.Timer Package laya.utils 类 public class Timer Inheritance Timer → Object Timer 是时钟管理类。它是一个单例，不要手动实例化此类，应该通过 Laya.timer 访问。 Method 作用 Timer() 创建 Timer 类的一个实例。 callLater(caller:*, method:Function, args:Array = null):void 延迟执行。 clear(caller:*, method:Function):void 清理定时器。 clearAll(caller:*):void 清理对象身上的所有定时器。 frameLoop(delay:int, caller:*, method:Function, args:Array = null, coverBefore:Boolean = true):void 定时重复执行(基于帧率)。 loop(delay:int, caller:*, method:Function, args:Array = null, coverBefore:Boolean = true, jumpFrame:Boolean = false):void 定时重复执行。 2.使用新建一个正方体，加上timer.loop使它旋转： 1234567891011&#x2F;&#x2F;添加自定义模型 var box &#x3D; scene.addChild(new Laya.MeshSprite3D(new Laya.BoxMesh(1, 1, 1))); box.transform.rotate(new Laya.Vector3(0, 45, 0), false, false); var material &#x3D; new Laya.StandardMaterial(); material.diffuseTexture &#x3D; Laya.Texture2D.load(&quot;res&#x2F;layabox.png&quot;); box.meshRender.material &#x3D; material; let func &#x3D; function () &#123; box.transform.rotate(new Laya.Vector3(0, 0.01, 0)); &#125;; Laya.timer.loop(1, this, func); 添加clearAll()方法，使用setTimeOut两秒后clear掉定时器: 1234setTimeout(function () &#123; console.log(&#39;清理定时器&#39;); Laya.timer.clear(this, func);&#125;, 2000); 3.注意在使用laya.timer.loop之前，一定要先clear掉之前的定时器，否则会出现不可预期的BUG","categories":[{"name":"游戏","slug":"游戏","permalink":"https://www.extingstudio.com/categories/%E6%B8%B8%E6%88%8F/"},{"name":"LayaBox","slug":"LayaBox","permalink":"https://www.extingstudio.com/categories/LayaBox/"}],"tags":[{"name":"LayaBox","slug":"LayaBox","permalink":"https://www.extingstudio.com/tags/LayaBox/"}]},{"title":"使用Google Closure Compiler进行Js代码压缩","slug":"2018-09-03-JS_Minify_With_Google_Closure_Compiler","date":"2018-09-02T16:00:00.000Z","updated":"2020-08-25T07:39:15.135Z","comments":true,"path":"2018/09/03/2018-09-03-JS_Minify_With_Google_Closure_Compiler/","link":"","permalink":"https://www.extingstudio.com/2018/09/03/2018-09-03-JS_Minify_With_Google_Closure_Compiler/","excerpt":"","text":"1.Google Closure Compiler是什么？ The Closure Compiler is a tool for making JavaScript download and run faster. Instead of compiling from a source language to machine code, it compiles from JavaScript to better JavaScript. It parses your JavaScript, analyzes it, removes dead code and rewrites and minimizes what’s left. It also checks syntax, variable references, and types, and warns about common JavaScript pitfalls. Closure Compiler是一个使JavaScript下载和运行更快的工具。 它不是从源语言编译到机器代码，而是从JavaScript编译成更好的JavaScript。 它解析您的JavaScript，分析它，删除死代码并重写并最小化剩下的内容。 它还检查语法，变量引用和类型，并警告常见的JavaScript陷阱。 2.使用环境 平台：Mac OS 环境：Java 3.检查是否安装了Java环境打开终端，输入 java -version,输出java的版本说明已安装好了java，若报错，请安装java环境 4.Closure Compiler下载在Github上下载最新版的编译好的Compiler文件，解压出jar文件存放在项目外的目录下： 5.在终端中，输入命令，运行jar：1java -jar &#x2F;Users&#x2F;wangjun&#x2F;Git&#x2F;compiler.jar --js_output_file&#x3D;code.js &#39;&#x2F;Users&#x2F;wangjun&#x2F;Git&#x2F;WorkProject&#x2F;BallsRace&#x2F;release&#x2F;wxgame&#x2F;code.js&#39; /Users/wangjun/Git/compiler.jar 改为自己的电脑上compiler.jar的路径，code.js改为输出文件名，/Users/wangjun/Git/WorkProject/BallsRace/release/wxgame/code.js改为输出路径。（其他参数这里使用默认）运行后就可以看到生成了压缩的JS文件了。压缩前后文件大小对比，压缩效果还是很明显的： 6.使用sh脚本实现自动化打包压缩Js文件由于我是使用Laya Box引擎做游戏开发的，每次打包都需要手动敲代码进行代码压缩，并且还需要手动删除打包后多余的库文件，流程实在很繁琐，所以我使用了Laya打包提供的后续执行命令功能，配合sh命令进行了打包压缩的自动化，大大提高了打包效率。打开Laya Box的打包页面编写sh命令： 1234cd &#x2F;Users&#x2F;wangjun&#x2F;Git&#x2F;WorkProject&#x2F;BallsRace&#x2F;release&#x2F;wxgame&#x2F;rm -rf .&#x2F;libsrm -rf .&#x2F;resjava -jar &#x2F;Users&#x2F;wangjun&#x2F;Git&#x2F;compiler.jar --js_output_file&#x3D;code.js &#39;&#x2F;Users&#x2F;wangjun&#x2F;Git&#x2F;WorkProject&#x2F;BallsRace&#x2F;release&#x2F;wxgame&#x2F;code.js&#39; 保存为.sh文件在后续执行脚本中填入.sh脚本的路径，在打包后就可以自动执行代码压缩，并且删除多余文件了。 7.帮助在终端中输入 java -jar compiler.jar --help 可以查看compiler的命令帮助和其他参数 8.其他我没用使用各种在线的Js代码压缩网站，原因如下： 在线压缩工具受网络状况影响； 和我的需求不一致，我需要的是压缩js文件，而不只是压缩js代码片段； 无法实现自动化脚本，上传-等待-压缩-下载，比较繁琐； 我觉得上传代码压缩并不安全，有泄漏源码的风险。 9.其他的JavaScript代码压缩工具UglifyJSYUI CompressorSmallerMinifier","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.extingstudio.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.extingstudio.com/tags/JavaScript/"}]},{"title":"什么是WebSocket？","slug":"2018-01-25-About_WebSocket","date":"2018-08-26T16:00:00.000Z","updated":"2020-08-25T07:35:35.927Z","comments":true,"path":"2018/08/27/2018-01-25-About_WebSocket/","link":"","permalink":"https://www.extingstudio.com/2018/08/27/2018-01-25-About_WebSocket/","excerpt":"","text":"什么是WebSocket？ WebSocket协议是一种基于ＴＣＰ的一种新的网络协议。他实现了浏览器与服务器全双工(full-duplex)通信—-允许服务器主动发送信息给客户端。 —-百度百科 实现原理 在实现websocket连线过程中，需要通过浏览器发出websocket连线请求，然后服务器发出回应，这个过程通常称为“握手” 。在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处： 1. Header 互相沟通的Header是很小的-大概只有 2 Bytes。 2. Server Push 服务器的推送，服务器不再被动的接收到浏览器的请求之后才返回数据，而是在有新数据时就主动推送给浏览器。 WebSocket与消息推送 - 张果 - 博客园https://www.cnblogs.com/best/archive/2016/09/12/5695570.html#_label2","categories":[{"name":"网络","slug":"网络","permalink":"https://www.extingstudio.com/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://www.extingstudio.com/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"使用MWeb进行Markdown博客编辑","slug":"2018-08-25-Mweb_for_markdown_on_mac","date":"2018-08-26T16:00:00.000Z","updated":"2020-08-25T07:39:07.496Z","comments":true,"path":"2018/08/27/2018-08-25-Mweb_for_markdown_on_mac/","link":"","permalink":"https://www.extingstudio.com/2018/08/27/2018-08-25-Mweb_for_markdown_on_mac/","excerpt":"","text":"欢迎使用 MWebMWeb 是专业的 Markdown 写作、记笔记、静态博客生成软件，目前已支持 Mac，iPad 和 iPhone。MWeb 有以下特色： 软件本身： 使用原生的 macOS 技术打造，追求与系统的完美结合。 原则上，首先是追求界面简洁和高性能，然后才是强大易用，功能全面。 Markdown 语法： 使用 Github Flavored Markdown 语法，简称 GFM 语法。 支持表格、TOC、LaTeX、代码块、任务列表、脚注等。 画图库支持 mermaid, viz, echarts, plantuml, sequence, flow。 Markdown 辅助： 支持截图并粘贴、复制并粘贴、拖拽等方式插入图片并直接显示在编辑器内。 在兼容 Markdown 语法的情况下支持设置图片宽度。 好用的表格插入和 LaTeX 书写辅助。 Markdown 输出： 支持导出为图片、HTML、Epub、PDF、RTF、Docx。 支持发布到 Wordrpess、支持 Metaweblog API 协议的服务、Wordpress.com、印象笔记（Evernote）、Blogger、Medium、Tumblr。 图片上传服务（图床）支持 Google Photos、Imgur、七牛云、又拍云和自定义的图床服务。 Markdown 笔记： 强大的文档库支持分类树和标签管理文档，文档可归类于多个分类，可以把分类整个导出为 Epub、PDF 和生成静态网站。非常合适用于笔记、个人知识收集、管理和输出。 快速笔记：随意增加笔记及图片等素材，支持以天为单位把增加的素材组合在一个文档内，方便整理及记录历史收集情况。 快速搜索：目前已支持全局快捷键调出搜索。 外部 Markdown 文档： 外部 Markdown 文档使用外部模式管理。外部模式使用目录树的方式编辑和管理你的 markdown 文档，还能很好的支持 gitbook、JekyII、hexo 等等编辑和图片插入。 MWeb 文档：如果要更详细了解 MWeb，建议你一定要去看一下官网的帮助文档，网址为：https://zh.mweb.im/help.html。我们建议在使用文档库之前，一定要阅读一下 MWeb 文档库详细介绍 这篇文章，以便更好的使用文档库。","categories":[{"name":"博客","slug":"博客","permalink":"https://www.extingstudio.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.extingstudio.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"关于游戏状态同步","slug":"2018-01-23-Game_State_Sync","date":"2017-09-04T16:00:00.000Z","updated":"2020-08-25T07:35:19.329Z","comments":true,"path":"2017/09/05/2018-01-23-Game_State_Sync/","link":"","permalink":"https://www.extingstudio.com/2017/09/05/2018-01-23-Game_State_Sync/","excerpt":"","text":"关于游戏状态同步 如何进行网络同步？ 状态同步： 状态同步 的关键在于服务器维护整个游戏逻辑，客户端相当于遥控器对游戏服务器发送指令，当服务器状态发生变化时，向玩家发送消息，玩家端仅展示动画。 帧同步： 帧同步中服务器不处理游戏逻辑，仅转发玩家的包。游戏客户端需要处理所有的游戏逻辑。帧同步适用于及时性比较强的游戏。 回合同步： 回合同步类似于帧同步，也是在服务端进行计算，但仅仅在发生动作时向服务器发送自己的动作。 轨迹同步： 轨迹同步即服务端记录玩家的轨迹，一个客户端请求另一个客户端的轨迹，适用于玩家之间没有相互影响的游戏。","categories":[{"name":"游戏","slug":"游戏","permalink":"https://www.extingstudio.com/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"https://www.extingstudio.com/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"Jekyll搭建个人博客","slug":"2018-08-25-jekyll_tutorials","date":"2017-09-04T16:00:00.000Z","updated":"2020-08-25T07:38:25.221Z","comments":true,"path":"2017/09/05/2018-08-25-jekyll_tutorials/","link":"","permalink":"https://www.extingstudio.com/2017/09/05/2018-08-25-jekyll_tutorials/","excerpt":"","text":"这篇文章主要讲的是如何使用和修改我的博客主题，文章内容含以下几点： 修改博客基础信息 发布文章 修改博客样式 添加文章字数统计和阅读时间估算 添加网易云音乐播放插件 博客模板根目录下的基本结构为 123456789101112131415161718192021.├── _config.yml ├── _includes ├── _layouts├── _posts├── _site├── 404.html├── about.md├── archive.html├── CNAME├── css├── feed.xml├── Gemfile├── Gemfile.lock├── images├── index.html├── js├── Rakefile├── README.md└── tags.html _config.yml 是博客的配置文件，内容如图所示 title：网站名称subtitle：网站副标题desciption：网站描述avatarTitle：头像标题avatarDesc：头像描述url：网站链接comment：评论系统，这里我是用的是国外的Disqus和livere，由于“众所周知”的原因，Disqus评论系统在国内并不可用，需要梯子才可以访问，虽然Disqus很好用==，所以我目前是使用的livere(来必力，韩国开发的)，相关配置和使用教程会在以后放出来。国内也有（大概？）好用的评论系统，例如：畅言、Valine等，可以自行测试使用。social：社交账号baidu：网站统计ga：Google Analytics谷歌网站分析 _includes/ 是网站模板包含的样式目录 _layout/ 是网站模板的样式模板目录 _post/ 是博客的文章目录，写好的markdown文件放在此目录，推送到github上，文章即可在博客上展示 _site/ 是网站的发布目录 404.html 404页面 about.md 关于我 页面 archive.html 文章发布页面 CNAME cname域名转发，可以在Github上直接设置 css,feed.html RSS订阅页面 images 图片存储目录，可以存储文章引用的图片 index.html 主页入口 js/ js文件目录 README.md Github readme页面 tags.html 博客tags添加文章字数统计和阅读时间在_layouts目录下的post.html中，添加代码12&lt;span &gt;本文总字数:&#123;&#123; page.content | strip_html | strip_newlines | remove: &quot; &quot; | size &#125;&#125;字 | &lt;&#x2F;span&gt;&lt;span &gt;阅读完需要约&#123;&#123; page.content | strip_html | strip_newlines | remove: &quot; &quot; | size | divided_by: 350 | plus: 1 &#125;&#125;分钟&lt;&#x2F;span&gt; 在文章的发布之后即可显示文章字数统计和阅读时间统计：添加网易云音乐播放插件在_includes目录下，添加html文件 cloud-music.html内容为： 12345&lt;!-- cloud music --&gt;&lt;!-- auto&#x3D;1 可以控制自动播放与否，当值为 1 即打开网页就自动播放，值为 0 时需要访客手动点击播放 --&gt;&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;330 height&#x3D;86 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;2&amp;id&#x3D;&#123;&#123; page.music-id &#125;&#125;&amp;auto&#x3D;1&amp;height&#x3D;66&quot;&gt;&lt;&#x2F;iframe&gt; 在post.html，文章正文的开头，添加代码： 123456&lt;div align&#x3D;&quot;center&quot;&gt; &lt;!-- 在正文开头添加网易云音乐插件 --&gt; &#123;% if page.music-id %&#125; &#123;% include cloud-music.html %&#125; &#123;% endif %&#125; &lt;&#x2F;div&gt; 在正文的markdown文本中，开头加上： music-id: 496869422 就可以在文章的开头显示网易云音乐播放器，music-id是音乐id，可以在网易云音乐播放器中查找 待更新","categories":[{"name":"博客","slug":"博客","permalink":"https://www.extingstudio.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.extingstudio.com/tags/%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"Git","slug":"Git","permalink":"https://www.extingstudio.com/categories/Git/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.extingstudio.com/categories/JavaScript/"},{"name":"工具","slug":"工具","permalink":"https://www.extingstudio.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"算法","slug":"算法","permalink":"https://www.extingstudio.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"软件","slug":"软件","permalink":"https://www.extingstudio.com/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"Mac","slug":"软件/Mac","permalink":"https://www.extingstudio.com/categories/%E8%BD%AF%E4%BB%B6/Mac/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.extingstudio.com/categories/LeetCode/"},{"name":"游戏","slug":"游戏","permalink":"https://www.extingstudio.com/categories/%E6%B8%B8%E6%88%8F/"},{"name":"LayaBox","slug":"LayaBox","permalink":"https://www.extingstudio.com/categories/LayaBox/"},{"name":"网络","slug":"网络","permalink":"https://www.extingstudio.com/categories/%E7%BD%91%E7%BB%9C/"},{"name":"博客","slug":"博客","permalink":"https://www.extingstudio.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.extingstudio.com/tags/Git/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.extingstudio.com/tags/JavaScript/"},{"name":"工具","slug":"工具","permalink":"https://www.extingstudio.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"算法","slug":"算法","permalink":"https://www.extingstudio.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"Mac","slug":"Mac","permalink":"https://www.extingstudio.com/tags/Mac/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.extingstudio.com/tags/LeetCode/"},{"name":"LayaBox","slug":"LayaBox","permalink":"https://www.extingstudio.com/tags/LayaBox/"},{"name":"网络","slug":"网络","permalink":"https://www.extingstudio.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"博客","slug":"博客","permalink":"https://www.extingstudio.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"游戏","slug":"游戏","permalink":"https://www.extingstudio.com/tags/%E6%B8%B8%E6%88%8F/"}]}