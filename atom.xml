<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>忆星辰 | 博客</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://www.extingstudio.com/atom.xml" rel="self"/>
  
  <link href="https://www.extingstudio.com/"/>
  <updated>2020-09-02T16:00:00.000Z</updated>
  <id>https://www.extingstudio.com/</id>
  
  <author>
    <name>Akimoto</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Git Submodule 对Hexo 博客主题进行管理与更新</title>
    <link href="https://www.extingstudio.com/2020/09/03/2020-09-03-Git-SubModule-Usage/"/>
    <id>https://www.extingstudio.com/2020/09/03/2020-09-03-Git-SubModule-Usage/</id>
    <published>2020-09-02T16:00:00.000Z</published>
    <updated>2020-09-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在使用Hexo搭建静态博客的时候，通常都会使用一个他人(自己)开发的主题，而这个主题往往是一个独立的Git仓库，自己的Hexo静态博客一般也是一个Git仓库，他们之间的关系是 博客仓库 <strong>包含</strong> 主题仓库： …/BlogRepo/themes/volantis/…  ，主仓库由使用者自己维护，主题仓库由主题作者进行维护与更新，无论是自己开发主题，还是是用别人开发的主题，都需要在主题更新或者修复BUG的时候对自己正在使用的主题代码进行更新，如果自己想要对主题进行修改也需要对这个仓库进行维护, 这时候就需要使用 Git Submodule 来对这个在主仓库中的子仓库进行 Git 管理</p></blockquote><a id="more"></a><div class="note 准备环境"><p>Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)<br>Git<br>注：<br>Hexo版本：5.0+    最低兼容版本：10.13.0</p></div><h1 id="Git-介绍"><a href="#Git-介绍" class="headerlink" title="Git 介绍"></a>Git 介绍</h1><p><a href="https://git-scm.com/">Git</a>是一个免费的开源 分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有内容。Git下载地址：<a href="https://git-scm.com/">Git</a><br>Git 常用命令可见这片文章：<a href="https://www.extingstudio.com/2019/09/10/2019-09-10-The_Most%20Commonly_Used_Git_Command_At_Work/">工作中最常用的Git命令及常见错误解决方案</a></p><h1 id="Git-子模块-Submodule介绍"><a href="#Git-子模块-Submodule介绍" class="headerlink" title="Git 子模块 Submodule介绍"></a>Git 子模块 Submodule介绍</h1><h1 id="使用Git-Submodule子模块对主题进行管理与更新"><a href="#使用Git-Submodule子模块对主题进行管理与更新" class="headerlink" title="使用Git Submodule子模块对主题进行管理与更新"></a>使用Git Submodule子模块对主题进行管理与更新</h1><blockquote><p>已有Hexo仓库和主题仓库的，可以直接跳到步骤8。</p></blockquote><ol><li>在自己的 GitHub 上新建一个仓库，用于存放自己博客的源码，注意：这个仓库不是 GitHub Pages 所在的仓库，并不用于发布博客，并且里面的配置文件可能会存放自己的一些用户名、秘钥、Token等信息，因此可以将此仓库权限设为 Private :</li></ol><p><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200903202924.png?x-oss-process=style/Post" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200903202924.png?x-oss-process=style/Post" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><ol start="2"><li>点击Code，然后点击Use SSH， 复制下仓库地址：</li></ol><p><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200903204116.png?x-oss-process=style/Post" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200903204116.png?x-oss-process=style/Post" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><ol start="3"><li>使用 <code>git clone</code>命令将主仓库clone到本地：</li></ol><p><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200903204749.png?x-oss-process=style/Post" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200903204749.png?x-oss-process=style/Post" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><ol start="4"><li>cd 到仓库根目录下，使用 <code>hexo init folder/</code> 初始化一个hexo目录</li></ol><p><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200903205318.png?x-oss-process=style/Post" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200903205318.png?x-oss-process=style/Post" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><p>目录结构如下：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200903205627.png?x-oss-process=style/Post" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200903205627.png?x-oss-process=style/Post" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><ol start="5"><li><p>在GitHub上，点击 fork 将主题仓库fork到自己的账号下：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904200830.png?x-oss-process=style/Post" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904200830.png?x-oss-process=style/Post" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p></li><li><p>与步骤1，2一样，cd 到themes目录下，使用命令： <code>git clone https://github.com/volantis-x/hexo-theme-volantis volantis</code>，将fork的仓库 clone 到本地：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904200935.png?x-oss-process=style/Post" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904200935.png?x-oss-process=style/Post" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p></li></ol><p><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904195752.png?x-oss-process=style/Post" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904195752.png?x-oss-process=style/Post" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><ol start="7"><li><p>返回到Blog目录， 使用 <code>npm hexo-generator-search hexo-generator-json-content</code> 安装相关 node 依赖，使用 <code>npm hexo-renderer-stylus</code> 安装渲染器：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904200224.png?x-oss-process=style/Post" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904200224.png?x-oss-process=style/Post" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p></li><li><p>返回到主目录BlogMainTest下，添加 主题仓库volantis为主仓库的子模块，使用命令 <code>$ git submodule add fork的主题仓库地址 主题目录路径</code> ：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904202228.png?x-oss-process=style/Post" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904202228.png?x-oss-process=style/Post" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p></li><li><p>输入 <code>git status</code>，看是否多了一个 .gitmodules:<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904202444.png?x-oss-process=style/Post" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904202444.png?x-oss-process=style/Post" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p></li><li><p>输入 <code>git submodule</code> 查看子模块信息：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904202604.png?x-oss-process=style/Post" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904202604.png?x-oss-process=style/Post" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p></li><li><p>此时，子模块已经添加成功，当主题作者更新了主题仓库时，由于我们自己的子模块主题仓库是fork原作者的仓库，我们想要更新时，需要先从源仓库更新我们本地的子模块，再推送到我们自己的主题仓库。输入： <code>cd Blog/themes/volantis</code>,到主题子模块下，并输入 <code>git remote -v</code>,查看远程源仓库状态：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904203734.png?x-oss-process=style/Post" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904203734.png?x-oss-process=style/Post" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"><br>可以看到当前的远程仓库是我们fork的自己的主题仓库，使用命令 <code>git remote add upstream git@github.com:xxx/xxx.git</code>，将源作者仓库设为上游仓库，并拉取更新，命令步骤为：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream git@github.com:xxx&#x2F;xxx.git</span><br><span class="line">git fetch upstream</span><br><span class="line">git merge upstream&#x2F;master</span><br></pre></td></tr></table></figure><p><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904204121.png?x-oss-process=style/Post" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/post/20200904204121.png?x-oss-process=style/Post" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"><br>在本地合并完冲突后，add,并commit提交，最后使用 <code> git push origin master</code> ，推送到远端。</p><ol><li>以上就是整个管理博客仓库，并通过fork来及时更新主题仓库代码的整个流程了，有任何问题，可以再下方评论区留言告知，我会尽力解答。</li></ol><h1 id="Git-Submodule的常用命令及使用"><a href="#Git-Submodule的常用命令及使用" class="headerlink" title="Git Submodule的常用命令及使用"></a>Git Submodule的常用命令及使用</h1><p>子模块的添加<br><code>git submodule add &lt;url&gt; &lt;path&gt;</code><br>查看子模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule</span><br><span class="line">e33f854d3f51f5ebd771a68da05ad0371a3c0570 assets (heads&#x2F;master)</span><br></pre></td></tr></table></figure><p>更新子模块<br>更新项目内子模块到最新版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update</span><br></pre></td></tr></table></figure><p>更新子模块为远程项目的最新版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote</span><br></pre></td></tr></table></figure><p>删除子模块<br><code>rm -rf</code> 子模块目录 删除子模块目录及源码<br><code>vi .gitmodules</code> 删除项目目录下.gitmodules文件中子模块相关条目<br><code>vi .git/config</code> 删除配置项中子模块相关条目<br><code>rm .git/module/*</code> 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可<br>执行完成后，再执行添加子模块命令即可，如果仍然报错，执行如下：<br><code>git rm --cached</code> 子模块名称<br>完成删除后，提交到仓库即可。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ol><li>当主仓库中包含子仓库时，直接在主仓库提交代码会报错，无法提交，使用子模块的方式，才能正常提交代码。</li><li>如果你已经删除了主题仓库的.git相关文件夹，那么就无法成功添加子模块，这个时候需要从 步骤6 开始重新clone代码，重新添加 子模块，并设置上游仓库。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">Git-工具-子模块</a></p><p><a href="https://juejin.im/post/6844903572950401038">Git 子模块：git submodule</a></p><p><a href="https://blog.csdn.net/guotianqing/article/details/82391665">git中submodule子模块的添加、使用和删除</a></p><p><a href="https://blog.csdn.net/qq1332479771/article/details/56087333">github上fork了别人的项目后，再同步更新别人的提交</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在使用Hexo搭建静态博客的时候，通常都会使用一个他人(自己)开发的主题，而这个主题往往是一个独立的Git仓库，自己的Hexo静态博客一般也是一个Git仓库，他们之间的关系是 博客仓库 &lt;strong&gt;包含&lt;/strong&gt; 主题仓库： …/BlogRepo/themes/volantis/…  ，主仓库由使用者自己维护，主题仓库由主题作者进行维护与更新，无论是自己开发主题，还是是用别人开发的主题，都需要在主题更新或者修复BUG的时候对自己正在使用的主题代码进行更新，如果自己想要对主题进行修改也需要对这个仓库进行维护, 这时候就需要使用 Git Submodule 来对这个在主仓库中的子仓库进行 Git 管理&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="博客" scheme="https://www.extingstudio.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="Git" scheme="https://www.extingstudio.com/categories/Git/"/>
    
    <category term="Hexo" scheme="https://www.extingstudio.com/categories/Hexo/"/>
    
    
    <category term="Git" scheme="https://www.extingstudio.com/tags/Git/"/>
    
    <category term="Hexo" scheme="https://www.extingstudio.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>在GitHub仓库使用Git命令 遇到ssh_exchange_identification错误的解决办法</title>
    <link href="https://www.extingstudio.com/2020/08/10/2020-08-10-GitHub-Error/"/>
    <id>https://www.extingstudio.com/2020/08/10/2020-08-10-GitHub-Error/</id>
    <published>2020-08-09T16:00:00.000Z</published>
    <updated>2020-08-25T07:42:10.320Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/what-is-github-1-1.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/what-is-github-1-1.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="GitHub"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>记录一次遇到在GitHub上使用Git命令Pull仓库遇到的“疑难杂症”。</p></blockquote><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>起因是我写了一个Cocos Creator的通用的组件代码，想在GitHub上的个人仓库中保存下来，方便分享给他人，也以便今后自己用到方便查看，于是在GitHub上新建了一个公开的仓库，地址是：<a href="https://github.com/BillScott1024/RichTextTypingDemo">RichTextTypingDemo</a>， 然后在本地使用SourceTree去拉取Git仓库到本地，但是一直在加载，过一会儿就出现报错：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/QQ20200810-164246.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/QQ20200810-164246.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="img-01"><br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20200810164404.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20200810164404.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="img-02"><br>点开报错信息后显示：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20200810164446.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20200810164446.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="img-03"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssh_exchange_identification: read: Operation timed out</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">fatal: not a git repository (or any of the parent directories): .git</span><br><span class="line">ssh_exchange_identification: read: Operation timed out</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">ssh_exchange_identification: read: Operation timed out</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用Git命令报错：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20200810170612.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20200810170612.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="img-04"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br><span class="line">ssh_exchange_identification: read: Operation timed out</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><ol><li><p>我开始以为是我的GitHub的权限问题，或者是我的SSH 私钥Key过期了，因为我看到报错信息里有：<code>Please make sure you have the correct access rights</code>  于是删除了本地的SSH Key，并重新生成私钥，保存到GitHub的后台上，但重试后问题依旧。排除权限问题。</p></li><li><p>然后我怀疑的原因是可能是我的梯子有问题，导致我的SourceTree无法链接GitHub的仓库，于是我打开Chrome进GitHub，连接正常，打开关闭ClashX Pro都可以正常进入GitHub主页，但是有可能是浏览器可以正常进去，但是命令行无法进入，我打开iTerm Ping了一下GitHub.com，果然无法Ping通,全都超时了：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20200810165338.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20200810165338.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="img-05"><br> 于是我把ClashX Pro提供的命令行翻♂墙命令<code>export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890</code>， 复制到iTerm中，依然无法Ping通，百度是可以正常Ping通的，排除WiFi网络问题:<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20200810165523.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20200810165523.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="img-06"></p></li><li><p>网上搜索了一番，没有找到解决问题的方法。但我突然想起来，我之前改过一次GitHub的Host，有可能是这个原因导致的于是找到Mac的Host文件，删除GitHub的Host：<br> <img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20200810165855.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20200810165855.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="img-07"><br> Binggo！解决问题,代码仓库可以正常Pull和Push了：<br> <img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20200810170048.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20200810170048.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="img-08"></p></li></ol><p>当初改这个Host的原因是我的GitHub和WIki上所有的用户头像和图标都无法加载，显示裂开，在网上找到的修改Host的方法解决的，现在删掉这条Host好像也没有问题了。</p><p>到此，问题解决完毕。</p>]]></content>
    
    
    <summary type="html">记录一次遇到在GitHub上使用Git命令Pull仓库遇到的“疑难杂症”。</summary>
    
    
    
    <category term="Git" scheme="https://www.extingstudio.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.extingstudio.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入浅出之理解闭包</title>
    <link href="https://www.extingstudio.com/2019/11/23/2019-11-23-Closure-in-JavaScript/"/>
    <id>https://www.extingstudio.com/2019/11/23/2019-11-23-Closure-in-JavaScript/</id>
    <published>2019-11-22T16:00:00.000Z</published>
    <updated>2020-08-25T07:42:01.599Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/d3254348-13a1-4d50-af7d-393051ee62c2.jpg" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/d3254348-13a1-4d50-af7d-393051ee62c2.jpg" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>函数与对其状态即词法环境（lexical environment）的引用共同构成闭包（closure）。也就是说，闭包<br>可以让你从内部函数访问外部函数作用域。在JavaScript，函数在每次创建时生成闭包。<br>— MDN Web docs</p></blockquote><h1 id="什么是“闭包”"><a href="#什么是“闭包”" class="headerlink" title="什么是“闭包”"></a>什么是“闭包”</h1><p>在MDN JavaScript官方文档上对<strong>“闭包”</strong>的描述是：函数与其状态即词法环境的引用，共同构成<strong>闭包</strong>。用更通俗的话来讲就是：闭包就是能够读取其他函数内部变量的函数。简单来说，闭包是一种函数，一种定义在函数内部的函数。本质上，闭包就是将函数内部和外部连接在一起的一座桥梁。<br>例子🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number = <span class="number">999</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> func2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = func1();</span><br><span class="line">result();               <span class="comment">// &quot;999&quot;</span></span><br><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 func2函数，就是闭包。</p><h1 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h1><ol><li>在外部能够读取函数内部的变量。</li><li>使变量的值一直存在于内存当中。</li><li>使用闭包模拟私有方法。</li></ol><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number = <span class="number">999</span>;</span><br><span class="line">    addFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        number += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> func2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = func1();</span><br><span class="line">result();       <span class="comment">// &quot;999&quot;</span></span><br><span class="line">addFunc();</span><br><span class="line">result();       <span class="comment">//&quot;1000&quot;</span></span><br></pre></td></tr></table></figure><h1 id="闭包会产生的问题（注意事项）"><a href="#闭包会产生的问题（注意事项）" class="headerlink" title="闭包会产生的问题（注意事项）"></a>闭包会产生的问题（注意事项）</h1><ol><li>由于闭包会使得函数中的变量都被保存在内存之中，即使函数已经执行完毕，这些局部变量也不会被垃圾回收器自动回收，有某些环境下容易导致内存泄漏。正确做法是，在退出函数之前，将不使用的变量都删除清空。</li><li>闭包会改变函数的值，而不只是改变函数变量的一个副本。</li><li>循环闭包问题。</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>本文参考：</p><blockquote><p><a href="https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">学习Javascript闭包（Closure）</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">闭包</a><br><a href="https://segmentfault.com/a/1190000003818163">用9种办法解决 JS 闭包经典面试题</a></p></blockquote>]]></content>
    
    
    <summary type="html">函数与对其状态即词法环境（lexical environment）的引用共同构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在JavaScript，函数在每次创建时生成闭包。</summary>
    
    
    
    <category term="JavaScript" scheme="https://www.extingstudio.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://www.extingstudio.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的内存管理机制</title>
    <link href="https://www.extingstudio.com/2019/11/19/2019-11-19-JavaScript-Memory-Management/"/>
    <id>https://www.extingstudio.com/2019/11/19/2019-11-19-JavaScript-Memory-Management/</id>
    <published>2019-11-18T16:00:00.000Z</published>
    <updated>2020-08-25T07:41:47.442Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/v2-f848e7e27202bdd70e647d9d1c7f17a7_1200x500.jpg" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/v2-f848e7e27202bdd70e647d9d1c7f17a7_1200x500.jpg" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><hr><blockquote><p>垃圾回收是一种自动的内存管理机制。当计算机上的动态内存不再需要的时候，就应当予以释放，以让出内存。直白点讲，就是程序是运行在内存里的，当声明一个变量、定义一个函数时都会占用内存。内存的容量是有限的，如果变量函数等只有产生没有消亡的过程，那内存总有会被完全占用的时候。这个时候，不仅程序自己无法正常运行，连其他程序都会受到影响。所以，在计算机当中，我们需要垃圾回收。需要注意的时候，JavaScript定义中的“自动”的意思是预言可以帮助我们回收内存垃圾，但并不代表我们不用关心内存管理，如果使用不当，JS中依旧会出现内存溢出的情况</p><p>— 知乎</p></blockquote><hr><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>像C预言这样的底层语言一般都有底层的内存管理接口，比如malloc()和free()。而JavaScript（以下简称JS）是在创建变量(对象，字符串等)时自动进行了内存分配，并且在不使用他们时“自动释放”。释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。</p><h1 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h1><p>不管什么程序语言，内存生命周期基本是一致的：</p><ol><li><p>分配你所需要的内存</p></li><li><p>使用分配到的内存(读,写)</p></li><li><p>不需要时将其归还释放</p></li></ol><p>所有语言的第一，第二部分都很清晰，第三步在低级语言（例如C语言）很清晰，但是在JavaScript这样的高级语言中，大部分是隐含的。因为JS具有<strong>自动垃圾回收机制</strong>（Garbage Collected）。但是作为开发者仍然需要关系内存的管理，因为这种自动回收机制，并不咋任何情况下都是智能的，仍会有发生内存泄漏的风险。</p><h2 id="JavaScript的内存分配"><a href="#JavaScript的内存分配" class="headerlink" title="JavaScript的内存分配"></a>JavaScript的内存分配</h2><h3 id="值的初始化"><a href="#值的初始化" class="headerlink" title="值的初始化"></a>值的初始化</h3><p>JS在定义变量的时候完成内存分配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var n &#x3D; 123;        &#x2F;&#x2F; 给数值变量分配内存</span><br><span class="line">var str &#x3D; &quot;hello&quot;;  &#x2F;&#x2F;给字符串分配内存</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    index: 0,</span><br><span class="line">    name: null</span><br><span class="line">&#125;;                  &#x2F;&#x2F;给对象和对象的值分配内存</span><br><span class="line"></span><br><span class="line">var array &#x3D; [1,2,3];        &#x2F;&#x2F;给数组分配内存</span><br><span class="line"></span><br><span class="line">function func(num)&#123;         &#x2F;&#x2F;给函数分配内存</span><br><span class="line">    return num + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="通过函数调用分配内存"><a href="#通过函数调用分配内存" class="headerlink" title="通过函数调用分配内存"></a>通过函数调用分配内存</h3><p>有些函数调用的结果是分配对象内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; new Data();          &#x2F;&#x2F;分配一个Data对象</span><br><span class="line"></span><br><span class="line">var element &#x3D; document.createElement(&#39;div&#39;);    &#x2F;&#x2F;分配一个DOM对象</span><br></pre></td></tr></table></figure><p>有些方法分配新变量或者新对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; &quot;azerty&quot;;</span><br><span class="line">var s2 &#x3D; s.substr(0, 3); &#x2F;&#x2F; s2 是一个新的字符串</span><br><span class="line">&#x2F;&#x2F; 因为字符串是不变量，</span><br><span class="line">&#x2F;&#x2F; JavaScript 可能决定不分配内存，</span><br><span class="line">&#x2F;&#x2F; 只是存储了 [0-3] 的范围。</span><br><span class="line"></span><br><span class="line">var a &#x3D; [&quot;ouais ouais&quot;, &quot;♂ ♂&quot;];</span><br><span class="line">var a2 &#x3D; [&quot;generation&quot;, &quot;♂ ♂&quot;];</span><br><span class="line">var a3 &#x3D; a.concat(a2); </span><br><span class="line">&#x2F;&#x2F; 新数组有四个元素，是 a 连接 a2 的结果</span><br></pre></td></tr></table></figure><h2 id="值的使用"><a href="#值的使用" class="headerlink" title="值的使用"></a>值的使用</h2><p>使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p><h2 id="内存不再需要使用时释放"><a href="#内存不再需要使用时释放" class="headerlink" title="内存不再需要使用时释放"></a>内存不再需要使用时释放</h2><p>大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“哪些被分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。</p><p>高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。</p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。</p><p>在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。</p><h2 id="引用计数（Reference-Counting）"><a href="#引用计数（Reference-Counting）" class="headerlink" title="引用计数（Reference Counting）"></a>引用计数（Reference Counting）</h2><p>这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; &#123; </span><br><span class="line">  a: &#123;</span><br><span class="line">    b:2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line">&#x2F;&#x2F; 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span><br><span class="line">&#x2F;&#x2F; 很显然，没有一个可以被垃圾收集</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var o2 &#x3D; o; &#x2F;&#x2F; o2变量是第二个对“这个对象”的引用</span><br><span class="line"></span><br><span class="line">o &#x3D; 1;      &#x2F;&#x2F; 现在，“这个对象”的原始引用o被o2替换了</span><br><span class="line"></span><br><span class="line">var oa &#x3D; o2.a; &#x2F;&#x2F; 引用“这个对象”的a属性</span><br><span class="line">&#x2F;&#x2F; 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span><br><span class="line"></span><br><span class="line">o2 &#x3D; &quot;yo&quot;; &#x2F;&#x2F; 最初的对象现在已经是零引用了</span><br><span class="line">           &#x2F;&#x2F; 他可以被垃圾回收了</span><br><span class="line">           &#x2F;&#x2F; 然而它的属性a的对象还在被oa引用，所以还不能回收</span><br><span class="line"></span><br><span class="line">oa &#x3D; null; &#x2F;&#x2F; a属性的那个对象现在也是零引用了</span><br><span class="line">           &#x2F;&#x2F; 它可以被垃圾回收了</span><br></pre></td></tr></table></figure><p><strong>限制：循环引用</strong><br>该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  var o &#x3D; &#123;&#125;;</span><br><span class="line">  var o2 &#x3D; &#123;&#125;;</span><br><span class="line">  o.a &#x3D; o2; &#x2F;&#x2F; o 引用 o2</span><br><span class="line">  o2.a &#x3D; o; &#x2F;&#x2F; o2 引用 o</span><br><span class="line"></span><br><span class="line">  return &quot;azerty&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><h2 id="标记清除（Mark-and-Sweep）"><a href="#标记清除（Mark-and-Sweep）" class="headerlink" title="标记清除（Mark and Sweep）"></a>标记清除（Mark and Sweep）</h2><p>JavaScript 中有个全局对象，浏览器中是 window。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象…对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。<br>标记－清除法的一个问题就是不那么有效率，因为在标记－清除阶段，整个程序将会等待，所以如果程序出现卡顿的情况，那有可能是收集垃圾的过程。<br>2012 年起，所有现代浏览器都使用了这个方法，所有的改进也都是基于这个方法，比如标记-整理方法：<br>标记清除有一个问题，就是在清除之后，内存空间是不连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而标记-整理方法可以有效地解决这个问题。标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。不过可以想象，这种做法的效率没有标记-清除高。计算机中的很多做法都是互相妥协的结果，哪有什么十全十美的事儿呢。</p><p>那标记清除具体是如何呢？有以下几种算法：</p><ul><li>在JavaScript 中，全局变量（Global）和window 对象会一直存在，不会被垃圾收集器回收；</li><li>递归所用到的所有（包括变量和方法），都不会被回收；</li><li>所有没有被标记为“活跃（active）”的，都会被认为是垃圾，收集器释放会回收垃圾，并把内存还给操作系统。</li></ul><h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>什么是内存泄漏？内存泄漏指的是计算机可用内存越来越少，主要是因为程序无法自动释放那些不再使用的内存。</p><p>导致内存泄漏的原因有几种。</p><h2 id="1-循环引用"><a href="#1-循环引用" class="headerlink" title="1 循环引用"></a>1 循环引用</h2><p>就是上面介绍的循环引用的例子🌰。标记-清除算法可以解决这个问题。在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。</p><h2 id="2-无意的全局变量"><a href="#2-无意的全局变量" class="headerlink" title="2 无意的全局变量"></a>2 无意的全局变量</h2><p>有时候本希望声明一个局部变量却无意声明了一个全局变量，这个全局变量会得到window的引用（在浏览器中），bar 实际上是window.bar,它的作用域在window上，所以当foo方法执行结束后，它也不会被回收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(arg) &#123;</span><br><span class="line">    bar &#x3D; &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>同理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    this.bar &#x3D; &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foo方法为全局方法，其中的this指向window，在类中指向类。</p><h2 id="3-未取消的计时器和回调函数"><a href="#3-未取消的计时器和回调函数" class="headerlink" title="3 未取消的计时器和回调函数"></a>3 未取消的计时器和回调函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let someResource &#x3D; getData();</span><br><span class="line">setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">    const node &#x3D; document.getElementById(&#39;Node&#39;);</span><br><span class="line">    if(node) &#123;</span><br><span class="line">        node.innerHTML &#x3D; JSON.stringify(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><p>上面的例子中，我们每隔一秒就将得到的数据放入到文档节点中去。但在 setInterval 没有结束前，回调函数里的变量以及回调函数本身都无法被回收。那什么才叫结束呢？就是调用了 clearInterval。如果回调函数内没有做什么事情，并且也没有被 clear 掉的话，就会造成内存泄漏。不仅如此，如果回调函数没有被回收，那么回调函数内依赖的变量也没法被回收。上面的例子中，someResource 就没法被回收。同样的，setTiemout 也会有同样的问题。所以，当不需要 interval 或者 timeout 时，最好调用 clearInterval 或者 clearTimeout。</p><h2 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4 闭包"></a>4 闭包</h2><ol><li>在闭包中引入闭包外部的变量时，当闭包结束时，此对象无法被垃圾回收（GC）</li><li>闭包可以维持函数内局部变量，使其得不到释放。<br>例子：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; function() &#123;</span><br><span class="line">  var largeStr &#x3D; new Array(1000000).join(&#39;x&#39;);</span><br><span class="line">  return function() &#123;</span><br><span class="line">    return largeStr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h2 id="5-自动类型装箱"><a href="#5-自动类型装箱" class="headerlink" title="5 自动类型装箱"></a>5 自动类型装箱</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; &quot;test test&quot;;</span><br><span class="line">alert(s.length);</span><br></pre></td></tr></table></figure><p>s 本身是一个 string 而非 object，它没有 length 属性，所以当访问 length 时，JS 引擎会自动创建一个临时 String 对象封装 s，而这个对象一定会泄漏。这个 bug 匪夷所思，所幸解决起来相当容易，记得所有值类型做.运算之前先显示转换一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; &quot;test test&quot;;</span><br><span class="line">alert(new String(s).length);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="确保不会内存泄漏"><a href="#确保不会内存泄漏" class="headerlink" title="确保不会内存泄漏"></a>确保不会内存泄漏</h1><p>在游戏开发中，需要尽量避免内存泄漏的可能性，作为开发者，在编码过程中至少应当注意：</p><ol><li>对于不需要使用的数据，将其置为null，来“解除引用”。<strong>注意：</strong>解除一个值的引用不代表它会立刻被垃圾回收期回收内存，而是在下一个垃圾回收周期的时候，垃圾回收期能知道这个值是可以被回收的。</li><li>清空数组时建议的做法是array.length = 0,而不是array = []，因为这种写法会创建新的数组去覆盖原来的数组。</li><li>用完的setTimeout和setInterval一定要记得clearTimeout和clearInterval，避免内存泄漏。</li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="垃圾回收机制的触发时间"><a href="#垃圾回收机制的触发时间" class="headerlink" title="垃圾回收机制的触发时间"></a>垃圾回收机制的触发时间</h2><ol><li><p>什么时候触发垃圾回收？</p><p> 垃圾回收周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6 的垃圾回收是根据内存分配量运行的，当环境中存在 256 个变量、4096 个对象、64K 的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好嘛？但是如果环境中就是有这么多变量一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法玩了。</p><p> 微软在 IE7 中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，如果垃圾回收器回收的内存分配量低于程序占用内存的 15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临界条件翻倍，如果回收的内存高于 85%，说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作智能了很多。</p></li><li><p>合理的 GC 方案</p><ol><li>JavaScript 引擎基础 GC 方案是（simple GC）：mark and sweep（标记清除），即：<br>遍历所有可访问的对象。<br>回收已不可访问的对象。</li><li>GC 的缺陷<br>和其他语言一样，JavaScript 的 GC 策略也无法避免一个问题：GC 时，停止响应其他操作，这是为了安全考虑。而 JavaScript 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免 GC 造成的长时间停止响应（造成卡顿）。</li></ol></li></ol><blockquote><p>摘录、总结内容来自于微信公众号/知乎/Google<br>如有侵权，请联系删除，谢谢！</p></blockquote>]]></content>
    
    
    <summary type="html">垃圾回收是一种自动的内存管理机制。当计算机上的动态内存不再需要的时候，就应当予以释放，以让出内存。直白点讲，就是程序是运行在内存里的，当声明一个变量、定义一个函数时都会占用内存。内存的容量是有限的，如果变量函数等只有产生没有消亡的过程，那内存总有会被完全占用的时候。这个时候，不仅程序自己无法正常运行，连其他程序都会受到影响。所以，在计算机当中，我们需要垃圾回收。需要注意的时候，JavaScript定义中的“自动”的意思是预言可以帮助我们回收内存垃圾，但并不代表我们不用关心内存管理，如果使用不当，JS中依旧会出现内存溢出的情况</summary>
    
    
    
    <category term="JavaScript" scheme="https://www.extingstudio.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://www.extingstudio.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入浅出之理解Null和Undefined</title>
    <link href="https://www.extingstudio.com/2019/11/19/2019-11-20-Difference-between-Null-and-Undefined/"/>
    <id>https://www.extingstudio.com/2019/11/19/2019-11-20-Difference-between-Null-and-Undefined/</id>
    <published>2019-11-18T16:00:00.000Z</published>
    <updated>2020-08-25T07:41:52.690Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/bg2014032801.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/bg2014032801.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="Null&amp;Undefined"></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在JavaScript有5个基本的简单数据类型：Number，String，Boolean，Null，Undefined 和一个复杂数据类型Object，其中<strong>Null</strong>和<strong>Undefined</strong>是最特殊的两个，在开发中经常会被搞混。</p><h1 id="为什么在JavaScript中会需要Null和Undefined两个值来表示“无”"><a href="#为什么在JavaScript中会需要Null和Undefined两个值来表示“无”" class="headerlink" title="为什么在JavaScript中会需要Null和Undefined两个值来表示“无”"></a>为什么在JavaScript中会需要Null和Undefined两个值来表示“无”</h1><h2 id="在JavaScript中，某些情况下null和undefined是相等的。"><a href="#在JavaScript中，某些情况下null和undefined是相等的。" class="headerlink" title="在JavaScript中，某些情况下null和undefined是相等的。"></a>在JavaScript中，某些情况下null和undefined是相等的。</h2><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (!undefined) </span><br><span class="line">    console.log(&#39;undefined is false&#39;);</span><br><span class="line">&#x2F;&#x2F; undefined is false</span><br><span class="line"></span><br><span class="line">if (!null) </span><br><span class="line">    console.log(&#39;null is false&#39;);</span><br><span class="line">&#x2F;&#x2F; null is false</span><br><span class="line"></span><br><span class="line">undefined &#x3D;&#x3D; null</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h2 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h2><h3 id="null表示“没有对象”，即该处不应该有值："><a href="#null表示“没有对象”，即该处不应该有值：" class="headerlink" title="null表示“没有对象”，即该处不应该有值："></a>null表示“没有对象”，即该处不应该有值：</h3><ol><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(Object.prototype)</span><br><span class="line">&#x2F;&#x2F; null</span><br></pre></td></tr></table></figure><h3 id="undefined表示“缺少值”，就是此处应该有一个值，但是还没有定义："><a href="#undefined表示“缺少值”，就是此处应该有一个值，但是还没有定义：" class="headerlink" title="undefined表示“缺少值”，就是此处应该有一个值，但是还没有定义："></a>undefined表示“缺少值”，就是此处应该有一个值，但是还没有定义：</h3><ol><li>变量被声明了，但还没有赋值，就等于undefined。</li><li>调用函数的时候，本应提供的参数没有提供，该参数就为undefined。</li><li>一个对象没有赋值的属性，该属性的值就位undefined。</li><li>函数没有return返回值时，默认返回undefined。</li></ol><p>例子： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i; i   <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = f();</span><br><span class="line">x <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="如何判断一个变量是否为null或undefined"><a href="#如何判断一个变量是否为null或undefined" class="headerlink" title="如何判断一个变量是否为null或undefined"></a>如何判断一个变量是否为null或undefined</h2><h3 id="undefined判断"><a href="#undefined判断" class="headerlink" title="undefined判断"></a>undefined判断</h3><p>如何判断一个变量是否为undefined，有两个方法：</p><ol><li>使用严格相等操作符 === 或 严格不相等操作符 ！== ，因为标准相等操作符 == 还会检查变量是否为null，为null的时候也会返回true。</li><li>使用 typeof 操作符，对于未定义的变量只能使用这种方法判断，否则会<strong>报错</strong>。</li></ol><p><strong>注意</strong><br>由于undefined未被JS设置为保留关键字，因此在代码中将变量名取为undefined是不会报错的，因此当undefined作为变量被重写了之后，用上面的判断方法就会失效（虽然正常情况下应该不会有开发者这样做。。。），例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var undefined &#x3D; 1;</span><br><span class="line">if(1 &#x3D;&#x3D;&#x3D; undefined)&#123;    &#x2F;&#x2F; true</span><br><span class="line">    &#x2F;&#x2F;do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保万无一失的方法是使用void操作符：</p><blockquote><p>The void operator evaluates the given expression and then returns undefined.</p><p>void 运算符 对给定的表达式进行求值，然后返回 undefined</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data;</span><br><span class="line">console.log(data &#x3D;&#x3D;&#x3D; void 0); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><h3 id="null判断"><a href="#null判断" class="headerlink" title="null判断"></a>null判断</h3><p>当使用typeof null的时候，返回值会是一个“object”，从逻辑角度来看，null值表示一个空对象指针，它代表的其实就是一个<strong>空对象</strong>，所以使用typeof操作符检测时返回”object”也是可以理解的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; null;</span><br><span class="line">console.log(typeof data); &#x2F;&#x2F; &quot;object&quot;</span><br></pre></td></tr></table></figure><p>正确的判断方法是使用严格相等操作符 === ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(data === <span class="literal">null</span>)&#123;  <span class="comment">// true</span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&quot;data中没有保存对象引用！&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="null和undefined的不同用法"><a href="#null和undefined的不同用法" class="headerlink" title="null和undefined的不同用法"></a>null和undefined的不同用法</h2><h3 id="null的用法"><a href="#null的用法" class="headerlink" title="null的用法"></a>null的用法</h3><ul><li><p>当声明一个即将保存对象的变量，但还没有赋值时，应当初始化为null；</p></li><li><p>当一个对象不再使用的时候，应该赋值为null，以“解除引用”，以便垃圾回收器，在下一个垃圾回收周期回收这个对象（并不会立即释放对象所占的内存）；</p></li></ul><blockquote><p>引用转载来源<br><a href="https://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">阮一峰-undefined与null的区别</a><br><a href="https://juejin.im/post/5aa4f7cc518825557e780256">JavaScript深入理解之undefined与null</a></p></blockquote>]]></content>
    
    
    <summary type="html">在JavaScript有5个基本的简单数据类型：Number，String，Boolean，Null，Undefined 和一个复杂数据类型Object，其中**Null**和**Undefined**是最特殊的两个，在开发中经常会被搞混。</summary>
    
    
    
    <category term="JavaScript" scheme="https://www.extingstudio.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://www.extingstudio.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>分离歌曲音频中的人声和背景音乐</title>
    <link href="https://www.extingstudio.com/2019/11/06/2019-11-06-Seprate-Audio-Voice-By-Spleeter/"/>
    <id>https://www.extingstudio.com/2019/11/06/2019-11-06-Seprate-Audio-Voice-By-Spleeter/</id>
    <published>2019-11-05T16:00:00.000Z</published>
    <updated>2020-08-25T07:41:39.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从一首歌中分离人声和BGM-背景音乐"><a href="#从一首歌中分离人声和BGM-背景音乐" class="headerlink" title="从一首歌中分离人声和BGM(背景音乐)"></a>从一首歌中分离人声和BGM(背景音乐)</h1><p><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/spleeter_logo.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/spleeter_logo.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="Spleeter"></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>想要K歌却苦于找不到喜欢的音乐的纯BGM？想要去除歌曲中的各种乐器的背景音乐，来个清唱版？不如试试这个开源项目吧</p><p>来自法国的音乐流媒体公司 Deezer 开源了一个音轨分离软件 spleeter，只需输入一段命令就可以将音乐的人声和各种乐器声分离，支持 mp3、wav、ogg 等常见音频格式。</p><p>这款软件基于 TensorFlow 开发，效果拔群，有网友说自己曾经试过无数类似软件，spleeter 是最好用的一个。</p><p>我在配置好环境后，测试了一下，效果拔群，几乎是我使用过的最好的分离人声和消除背景音的工具。我使用的测试歌曲是米津玄师的《Lemon》</p><p>点击蓝字播放↓<br>转换前：<a href="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/audio/Lemon-%E7%B1%B3%E6%B4%A5%E7%8E%84%E5%B8%88.mp3">原声</a><br>转换后的人声部分：<a href="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/audio/vocals.mp3">人声MP3</a><br>转换后的背景音乐部分：<a href="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/audio/accompaniment.mp3">背景音MP3</a></p><p>虽然网页上的音频经过了压缩，音质不太好，但是可以很明显的感受到，分离的效果是非常明显的，人声的音频几乎听不到BGM了，BGM的音频也只能听到一点点的不和谐。</p><p>spleeter 还支持 GPU 加速。如果在 GPU 上运行，会比实时分解速度快 100 倍，也就是说分解一首 5 分钟的歌曲只需要 3 秒。即使是使用CPU，分解这样一首4分钟的音频，也只用了不到1分钟的时间，个人使用上来说过绝对足够了。</p><p>GitHub项目地址：<a href="https://github.com/deezer/spleeter">Spleeter人声分离</a></p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><strong>操作系统</strong>： Mac OS / Windows / Linux<br><strong>Python</strong>： Version3.7 / Version 2.7<br><strong>Conda</strong>： Miniconda</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>安装Conda环境</li><li>从GitHub上Clone项目到本地</li><li>使用Conda命令运行Spleeter完成人声音频分离</li></ol><h2 id="详细安装步骤"><a href="#详细安装步骤" class="headerlink" title="详细安装步骤"></a>详细安装步骤</h2><blockquote><p>这里只以MacOS为例，Windows的步骤大同小异，有问题可以留言。</p></blockquote><ol><li><p>在Conda的官网上下载自己计算机对应版本的Conda安装程序，或者包管理器进行安装，Conda官网地址点击这里<a href="https://docs.conda.io/en/latest/conda.html">Conda</a>，或者点击这里的下载页进行下载：<a href="https://docs.conda.io/en/latest/miniconda.html">Miniconda下载地址</a></p><p> 如下图，点击蓝字进行下载，32位的系统就下载32位的，64位的就下载64位的，Mac OS系统的直接下载.pkg文件就行。由于是国外的官网，可能下载会中断，耐心多下载几次即可，是在无法下载的可以在本文下面留言邮箱地址，我看到会把安装包发到你的邮箱📮里。<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20191106193236.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20191106193236.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p></li><li><p>下载完成后，点击安装<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20191106193303.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20191106193303.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"><br> 如果遇到未信任的程序，无法安装，请到系统偏好设置-&gt;安全与隐私-&gt;允许从以下位置下载应用勾选AppStore和被认可的开发者<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20191106193211.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20191106193211.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p></li><li><p>安装完成后，打开命令行工具iTerm，在命令行中输入：conda -V,如果输出不是command not found，那么Conda环境就安装成功了<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20191106194445.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20191106194445.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p></li><li><p>如果本机有git，那么直接输入<br> <code>git clone https://github.com/deezer/spleeter</code><br> 克隆git仓库到本地，没有安装git的话点击：<a href="https://github.com/deezer/spleeter">Spleeter人声分离</a>，点击DownloadZIP，下载到本地<br> <img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20191106194708.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20191106194708.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p></li></ol><p>5.进入项目所在的文件夹，打开命令行，在命令行中输入命令：<br>    <code>conda env create -f spleeter/conda/spleeter-cpu.yaml</code><br>    按回车后，再输入命令<br>    <code>conda activate spleeter-cpu</code></p><p>如果想换成 GPU 环境，只需将上述代码中的 spleeter-cpu 换成 spleeter-gpu。</p><p>最后再输入：<br><code>spleeter separate -i audio_example.mp3 -o audio_output -p spleeter:4stems</code></p><p>在分离音轨的命令中，加入选项 - p spleeter:4stems 来指定音轨数量，如果不加，系统默认分离为 2 个音轨。</p><p>最终乐器和人声将以 wav 文件的格式保存在 audio_output 文件夹中。<br>分离过程可以在 GPU 或 CPU 上执行。在 GPU 上运行，速度非常快，可以实现 100 倍的加速。<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20191106195126.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20191106195126.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p>]]></content>
    
    
    <summary type="html">想要K歌却苦于找不到喜欢的音乐的纯BGM？想要去除歌曲中的各种乐器的背景音乐，来个清唱版？不如试试这个开源项目吧.来自法国的音乐流媒体公司 Deezer 开源了一个音轨分离软件 spleeter，只需输入一段命令就可以将音乐的人声和各种乐器声分离，支持 mp3、wav、ogg 等常见音频格式。这款软件基于 TensorFlow 开发，效果拔群，有网友说自己曾经试过无数类似软件，spleeter 是最好用的一个。我在配置好环境后，测试了一下，效果拔群，几乎是我使用过的最好的分离人声和消除背景音的工具。我使用的测试歌曲是米津玄师的《Lemon》</summary>
    
    
    
    <category term="工具" scheme="https://www.extingstudio.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://www.extingstudio.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>洗牌算法/Fisher-Yates Shuffle</title>
    <link href="https://www.extingstudio.com/2019/09/20/2019-09-20-Fisher-Yates%20-Shuffle/"/>
    <id>https://www.extingstudio.com/2019/09/20/2019-09-20-Fisher-Yates%20-Shuffle/</id>
    <published>2019-09-19T16:00:00.000Z</published>
    <updated>2020-08-25T07:41:30.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="洗牌算法-Fisher-Yates-Shuffle"><a href="#洗牌算法-Fisher-Yates-Shuffle" class="headerlink" title="洗牌算法/Fisher-Yates Shuffle"></a>洗牌算法/Fisher-Yates Shuffle</h1><h3 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h3><p>在游戏开发中，经常会遇到需要将一个数组打乱的情况，例如，在一个卡牌系统中需要做一个抽卡，给你8张卡牌，从中抽取一张，并获得奖励：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190920164546.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190920164546.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"><br>使用洗牌算法打乱卡牌中的奖励，实现随机抽奖的效果：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190920164620.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190920164620.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><h3 id="Fisher-Yates-Shuffle算法"><a href="#Fisher-Yates-Shuffle算法" class="headerlink" title="Fisher-Yates Shuffle算法"></a>Fisher-Yates Shuffle算法</h3><p>费舍尔·耶茨洗牌算法的做法是：给出数组Array，数组长度为n，取数组最后一个值M，再从数组的前n-1个元素中随机取一个值N，与最后一个值交换位置M，再取数组倒数第二个值N1，在前n-2各元素中随机取一个值M1与N1交换位置，依次取完剩下的值，完成数组打乱，算法的时间复杂度为O(n)。<br>JS实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [0, 1, 2, 3, 4];</span><br><span class="line">for(let i  &#x3D; 0;   i&lt; arr.length;i++)&#123;</span><br><span class="line">    const random &#x3D; Math.floor(Math.random() * (i+1));</span><br><span class="line">    [arr[i], arr[random]] &#x3D; [arr[random], arr[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单的打乱算法"><a href="#简单的打乱算法" class="headerlink" title="简单的打乱算法"></a>简单的打乱算法</h3><p>还有另一种简单的随机打乱算法，虽然也可以实现随机打乱数组，但是在大量的结果上并不能实现完全的随机，原因是JS源码中的sort()方法：</p><blockquote><p>v8 在处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于10时，使用插入排序；反之，使用快排。</p></blockquote><p>其实不管用什么排序方法，大多数排序算法的时间复杂度介于 O(n) 到 O(n2) 之间，元素之间的比较次数通常情况下要远小于 n(n-1)/2，也就意味着有一些元素之间根本就没机会相比较（也就没有了随机交换的可能），这些 sort 随机排序的算法自然也不能真正随机。 通俗的说，其实我们使用 array.sort 进行乱序，理想的方案或者说纯乱序的方案是：数组中每两个元素都要进行比较，这个比较有 50% 的交换位置概率。如此一来，总共比较次数一定为 n(n-1)。而在 sort 排序算法中，大多数情况都不会满足这样的条件。因而当然不是完全随机的结果了。<br>JS实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [0, 1, 2, 3, 4];</span><br><span class="line">arr.sort(() &#x3D;&gt; Math.random() &gt; 0.5);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在游戏开发中，经常会遇到需要将一个数组打乱的情况，例如，在一个卡牌系统中需要做一个抽卡，给你8张卡牌，从中抽取一张，并获得奖励：费舍尔·耶茨洗牌算法的做法是：给出数组Array，数组长度为n，取数组最后一个值M，再从数组的前n-1个元素中随机取一个值N，与最后一个值交换位置M，再取数组倒数第二个值N1，在前n-2各元素中随机取一个值M1与N1交换位置，依次取完剩下的值，完成数组打乱，算法的时间复杂度为O(n)。</summary>
    
    
    
    <category term="算法" scheme="https://www.extingstudio.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.extingstudio.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>工作中最常用的Git命令及常见错误解决方案</title>
    <link href="https://www.extingstudio.com/2019/09/10/2019-09-10-The_Most%20Commonly_Used_Git_Command_At_Work/"/>
    <id>https://www.extingstudio.com/2019/09/10/2019-09-10-The_Most%20Commonly_Used_Git_Command_At_Work/</id>
    <published>2019-09-09T16:00:00.000Z</published>
    <updated>2020-09-07T13:01:59.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git主要操作命令"><a href="#Git主要操作命令" class="headerlink" title="Git主要操作命令"></a>Git主要操作命令</h1><h4 id="1-git-clone-克隆远程代码仓库"><a href="#1-git-clone-克隆远程代码仓库" class="headerlink" title="1. git clone   克隆远程代码仓库"></a>1. git clone   <code>克隆远程代码仓库</code></h4><h4 id="2-git-pull-git-pull-–rebase-拉取远程代码库到本地"><a href="#2-git-pull-git-pull-–rebase-拉取远程代码库到本地" class="headerlink" title="2. git pull / git pull –rebase 拉取远程代码库到本地"></a>2. git pull / git pull –rebase <code>拉取远程代码库到本地</code></h4><h4 id="3-git-rebase-–continue-如果git-pull后与本地修改有冲突，需要先解决冲突，并在Source-Tree中将冲突标记为与解决，使用git-rebase-continue合并冲突"><a href="#3-git-rebase-–continue-如果git-pull后与本地修改有冲突，需要先解决冲突，并在Source-Tree中将冲突标记为与解决，使用git-rebase-continue合并冲突" class="headerlink" title="3. git rebase –continue 如果git pull后与本地修改有冲突，需要先解决冲突，并在Source Tree中将冲突标记为与解决，使用git rebase --continue合并冲突"></a>3. git rebase –continue <code>如果git pull后与本地修改有冲突，需要先解决冲突，并在Source Tree中将冲突标记为与解决，使用git rebase --continue合并冲突</code></h4><h4 id="4-git-commit-m’xxx’-提交修改到本地"><a href="#4-git-commit-m’xxx’-提交修改到本地" class="headerlink" title="4. git commit -m’xxx’ 提交修改到本地"></a>4. git commit -m’xxx’ <code>提交修改到本地</code></h4><h4 id="5-git-push-origin-master-branch-推送本地修改到远端库"><a href="#5-git-push-origin-master-branch-推送本地修改到远端库" class="headerlink" title="5. git push origin master/[branch] 推送本地修改到远端库"></a>5. git push origin master/[branch] <code>推送本地修改到远端库</code></h4><hr><p>推荐一个学习Git命令的网站：<a href="https://learngitbranching.js.org/">Learn Git Branching</a>,这个是网站的首页：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190911194932.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190911194932.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="Learn Git Branching"><br>    在这个网站的沙盒中可以使用各种Git命令去熟悉Git命令的作用和使用方法而不不担心损坏自己电脑中的文件。<br>    <img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190911195434.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190911195434.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"><br>    并且可以通过动画的方式去理解Git中的各种合并，分支等操作。</p><hr><h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><ul><li>git status <code>查看当前本地库状态</code></li><li>git log <code>查看最近的commit记录</code></li><li>git branch <code>查看当前分支</code></li></ul><h1 id="Git-常见误操作及解决方式"><a href="#Git-常见误操作及解决方式" class="headerlink" title="Git 常见误操作及解决方式"></a>Git 常见误操作及解决方式</h1><p>** 1. 多个分支一起开发的时候将A分支的改动错误的提交到B的场景：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">将该分支的本不应该提交的commit撤销</span><br><span class="line">git reset HEAD^</span><br><span class="line"></span><br><span class="line">按需选择想要回到哪个版本</span><br><span class="line">回到HEAD</span><br><span class="line">git reset --soft HEAD</span><br><span class="line"></span><br><span class="line">回到HEAD的前一个版本</span><br><span class="line">git reset --soft HEAD^</span><br><span class="line"></span><br><span class="line">回到HEAD的前10个版本</span><br><span class="line">git reset --soft HEAD~5 </span><br><span class="line"></span><br><span class="line">利用id回到指定版本</span><br><span class="line">git reset --soft a06ef2f</span><br><span class="line"></span><br><span class="line">将撤销的代码暂存起来</span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line">切换到正确的分支</span><br><span class="line">git checkout feat&#x2F;xxx</span><br><span class="line"></span><br><span class="line">重新应用缓存 </span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line">在正确的分支进行提交操作</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;update xxxx&quot;</span><br></pre></td></tr></table></figure><h2 id="Git只提交部分修改的文件（提交指定文件）"><a href="#Git只提交部分修改的文件（提交指定文件）" class="headerlink" title="Git只提交部分修改的文件（提交指定文件）"></a>Git只提交部分修改的文件（提交指定文件）</h2><p>在我们的项目中，经常会在本地编译一些代码，还未写完，测试那边来告诉你要改改某个文件的bug，非常着急，此时改完了，提交的时候，自己还在编译的代码并不想提交，此时，你可以利用git这些指令帮助你！</p><p>1/ git status -s 查看仓库状态</p><p>2/ git add src/components/文件名 添加需要提交的文件名（加路径–参考git status 打印出来的文件路径）</p><p>3/ git stash -u -k 忽略其他文件，把现修改的隐藏起来，这样提交的时候就不会提交未被add的文件</p><p>4/ git commit -m “哪里做了修改可写入…”</p><p>5/ git pull 拉取合并</p><p>6/ git push 推送到远程仓库</p><p>7/ git stash pop 恢复之前忽略的文件（非常重要的一步）</p><h2 id="Git-清除本地未跟踪的文件和目录"><a href="#Git-清除本地未跟踪的文件和目录" class="headerlink" title="Git 清除本地未跟踪的文件和目录"></a>Git 清除本地未跟踪的文件和目录</h2><p>有时候我们在打包之后引擎会自动生成一些多余的文件，这些文件不需要提交到远程库中，虽然可以通过 .gitignore添加忽略列表，但是，有时候这样做并不方便。可以使用命令 git clean:</p><p>git clean 命令支持以下参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clean [-d] [-f] [- ] [-n] [-q] [-e ] [-x | -X] [--] ...</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中几个主要参数用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-d   <span class="comment"># 删除未跟踪目录以及目录下的文件，如果目录下包含其他git仓库文件，并不会删除（-dff可以删除）。</span></span><br><span class="line">-f   <span class="comment"># 如果 git cofig 下的 clean.requireForce 为true，那么clean操作需要-f(--force)来强制执行。</span></span><br><span class="line">-    <span class="comment"># 进入交互模式</span></span><br><span class="line">-n   <span class="comment"># 查看将要被删除的文件，并不实际删除文件</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过以上几根参数组合，基本上可以满足删除未跟踪文件的需求了。例如在删除前先查看有哪些文件将被删除运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clean -n</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>想删除当前工作目录下的未跟踪文件，但不删除文件夹运行（如果 clean.requireForce 为 false 可以不加 -f 选项）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clean -f</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>想删除当前工作目录下的未跟踪文件以及文件夹运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -df</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">1. git clone 克隆远程代码仓库</summary>
    
    
    
    <category term="Git" scheme="https://www.extingstudio.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.extingstudio.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Mac常用软件工具合集（更新中...）</title>
    <link href="https://www.extingstudio.com/2018/11/06/2018-11-06-Mac_Most_Used_Software/"/>
    <id>https://www.extingstudio.com/2018/11/06/2018-11-06-Mac_Most_Used_Software/</id>
    <published>2018-11-05T16:00:00.000Z</published>
    <updated>2020-08-25T07:41:10.807Z</updated>
    
    <content type="html"><![CDATA[<hr><a href="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20181106115306.png" id="id">     <img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20181106115306.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20181106115306.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></a><hr><p>&emsp;</p><h1 id="1-软件列表"><a href="#1-软件列表" class="headerlink" title="1. 软件列表"></a>1. 软件列表</h1><p>&emsp;</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li>PDFelement 6 Pro (付费)</li><li>滴答清单</li><li>微小宝公众号版</li><li>Alfred 3</li><li>Archiver</li><li>Background Music</li><li>Backgrounds</li><li>BetterTouchTool</li><li>CleanMyMac X (付费)</li><li>iStat Menus</li><li>KCNScrew</li><li>NewFileMenu</li><li>Parallels Desktop</li><li>TeamViewer (免费)</li><li>Tuxera Disk Manager (付费)</li><li>iMazing (付费)</li><li>Rotato for mac(3D样机宣传视频制作软件)</li></ol><p>&emsp;</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ol><li>ShadowsocksX-NG-R8 (免费)</li><li>Coherence Pro (付费)</li><li>Google Chrome</li><li>Lonlife</li></ol><p>&emsp;</p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><ol><li>Unity (免费)</li><li>微信开发者工具</li><li>blender</li><li>CocosCreator</li><li>Dash</li><li>LayaAirIDE</li><li>Rhinoceros</li><li>Smaller</li><li>Sourcetree</li><li>TexturePacker</li><li>Tiled</li><li>Visual Studio Code</li><li>Visual Studio</li><li>Xcode</li><li>Beyond Compare</li></ol><p>&emsp;</p><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><ol><li>印象笔记 (免费)</li><li>Atom</li><li>Sublime Text</li><li>Microsoft Excel</li><li>Microsoft PowerPoint</li><li>Microsoft Word</li><li>MWeb (付费)</li><li>Notability (付费)</li><li>PDFelement Express</li><li>Ulysses</li></ol><p>&emsp;</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><ol><li>Reeder (免费)</li><li>Medium</li></ol><p>&emsp;</p><h2 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a>媒体</h2><ol><li>Adobe After Effects CC 2018 (付费)</li><li>Adobe Audition CC 2018 (付费)</li><li>Adobe Lightroom CC 2018 (付费)</li><li>Adobe Media Encoder CC 2018</li><li>Adobe Photoshop CC 2018</li><li>Adobe Premiere Pro CC 2018</li><li>Final Cut Pro</li><li>网易云音乐 (免费)</li><li>迅雷影音</li><li>LICEcap</li><li>OBS</li><li>Permute</li><li>PicGo</li><li>Sketch</li></ol><p>&emsp;</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ol><li>JDownloader2 (免费)</li><li>迅雷 2</li><li>Aria2GUI</li></ol><p>&emsp;</p><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><ol><li>WeChatPlugin-MacOS</li><li>baidu-dl</li><li>Full Page Screen Capture</li><li>Tampermonkey</li><li>Google 翻译</li><li>Pixlr Today</li><li>书签侧边栏</li><li>迅雷下载支持</li><li>Cocos Creator Inspector</li><li>页面自动刷新插件</li></ol><p>&emsp;</p><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><ol><li>多宝 (免费游戏平台)</li><li>英雄联盟</li><li>Call of Duty 4 - Modern Warfare</li><li>Dont Starve</li><li>Epic Games Launcher</li><li>Leo’s Fortune</li><li>Poly Bridge</li><li>Steam</li><li>This War of Mine</li></ol><p>&emsp;<br>&emsp;<br>&emsp;</p><hr><hr><h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><h2 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h2><ol><li><p>PDFelement 6 Pro (付费)</p><p> 用来阅读，编辑PDF文件，重点功能是可以直接编辑PDF文档，在别人分享，或者已经生成好的PDF文档中，修改文字和图片，还可以进行PDF签名。</p></li><li><p>滴答清单</p><p> 待办事项提醒工具，提供了Wedget。</p></li><li><p>微小宝公众号版</p><p> 管理公众号，可以同时登录多个公众号进行管理，查看粉丝数据，消息群发，统计图文消息。</p></li><li><p>Alfred 3 (<a href="http://xclient.info/s/alfred.html?t=89c7dd7c74349f5f5244ce976f151e723df05594">下载地址</a>)</p><p> Mac上的效率神器，提供全局搜索，高效率快捷键，堪比Mac上的 捷径</p></li><li><p>Archiver(<a href="http://xclient.info/s/archiver.html?t=25fbc2b02ef700cf706ca00a5ab138536c14e6c4">下载地址</a>)</p><p> Mac上较好用的解压工具，解压速度很快，解压缩的文件类型最全面，并且支持在Finder中点击右键解压缩，强力推荐。</p></li><li><p>Background Music</p><p> 神器！用于在Mac上设置不同app的音乐大小，在用过Windows后，再使用Mac的用户会有一个很大的不习惯的地方，就是Mac无法像Windows一样分别去改变不同app的音量大小，但是，在安装了这款小巧的APP之后，就可以在状态栏分别设置不同APP的音量大小了，并且可以设置开机启动，非常方便，也不会占用太大的内存。</p></li><li><p>Backgrounds (<a href="http://xclient.info/s/backgrounds.html?t=25fbc2b02ef700cf706ca00a5ab138536c14e6c4">下载地址</a>)</p><p> 用于在Mac上设置动态壁纸，性能占用较小，可以使用自己下载的视频/gif/电影等作为动态壁纸。</p></li><li><p>BetterTouchTool</p><p> 触控板增强工具</p></li><li><p>CleanMyMac X(暂无用永久免费的下载地址，可以留言邮箱，发到你的邮箱中)</p><p> Mac系统清理工具，虽说Mac不像Windows需要时常清理，但是用时间长了，系统缓存，软件卸载留存文件等，会越来越多，并且Mac的硬盘空间“寸土寸金”，有一款能方便快捷，智能的清理出一些硬盘空间还是必要的，在用过许多的清理助手和看过评价后，这款是比较简洁好用的，推荐。</p></li><li><p>iStat Menus</p><p>一款用于在Mac状态栏上实时查看网络上传下载速度，电脑运行温度的软件，虽然它还有，调节电脑风扇转速，查看硬盘状态，内存状态等等便捷功能，但我主要是用来查看网络状态，习惯了Windows上可以通过360，腾讯管家等实时查看网速的功能，这款小软件是非常好用的。</p></li><li><p>KCNScrew</p><p>软件序列号搜索工具，能搜到一些付费软件的序列号，太新的软件版本搜不到，老版本可以查得到。</p></li><li><p>NewFileMenu</p><p>用于在Finder中右键点击能直接新建文件的工具，类似Windows中在文件夹中新建右键文件，例如新建tet,word,ppt,excel等文件。</p></li><li><p>Parallels Desktop</p><p>Mac系统上最强大的虚拟机，可以在Mac上高性能运行Windows，Linux等系统，用来运行一些Windows独有的软件，游戏等都没有问题。强烈推荐。</p></li><li><p>TeamView<br>一款远程控制软件，支持Windows，Mac，iOS, Android多平台。</p></li><li><p>Tuxera Disk Manager (付费)</p><p>用于在Mac系统上读取的磁盘格式是NTFS(Windows系统文件格式)的硬盘。由于NTFS是Windows独有的文件格式，而Mac系统屏蔽了此格式的写入，只能通过另外的软件来读写。也可以通过将磁盘格式化为FAT32格式的文件格式，可以同时在Mac和Windows中读写文件，但是FAT32格式的文件系统并不支持单个文件大于4GB的存储，所以对于有大文件存储需求的用户来说，Tuxera Disk Manager是最好的选择。 </p></li><li><p>iMazing</p><p>Mac上比iTunes更好用的iPhone管理工具，可以用来备份，管理iPhone的照片，视频，文件等。   </p></li><li><p>Rotato for mac(3D样机宣传视频制作软件)<br>如图所示的3D样机展示工具，下载地址：<a href="https://www.macdown.com/mac/6521.html">Mac下载-Rotato</a><br>![Roato Demo](<a href="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/Rotato">https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/Rotato</a> Snapshot1.png)</p><h2 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h2></li><li><p>ShadowsocksX-NG-R8 (免费) (<a href="https://github.com/shadowsocks/ShadowsocksX-NG">下载地址</a>)</p><p> Mac上的梯(fan)子(qiang)工具，需要自行购买或者查找免费的SS账号，可以定于服务器节点，设定全局或者配置代理模式。技术开发者必备。</p></li><li><p>Coherence Pro (付费)</p><p> 暂无</p></li><li><p>Google Chrome (<a href="https://www.google.com/chrome/">下载地址</a>)</p><p> 最好用的浏览器，前端开发者必备。</p></li><li><p>Lonlife  (<a href="https://www.lonlife.cc/">下载地址</a>)</p><p> 玲珑加速器，外服游戏加速器，延迟低，效果好，售后服务好，需要付费购买账户，不过有免费试用时间。</p></li></ol><h2 id="开发-1"><a href="#开发-1" class="headerlink" title="开发"></a>开发</h2><p>1.Beyond Compare<br>    Beyond Compare 是一款强大专业的文件和文件夹对比工具。使用它可以很方便地比较出两个文件或文件夹的差异，相差的每一个字节用颜色加以标识，让您查看方便，支持众多种格式的对比。<br>只需使用简单操作方式方可开启快捷省事的文件对比体验，找出您所需差异、合并变化，然后同步文件，并生成报告一气呵成。<br>打开软件后的主界面：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190802152357.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190802152357.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><p>当我们需要对比两个文件夹的内容时，显示如下界面：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190802153228.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190802153228.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"><br>把我们需要对比的两个文件夹分别拖入左右两边，点击文件夹对比，双击文件夹可以展开文件夹，双击文件可以进入文件，查看文件内容，并进行左右文件的对比：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190802152918.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190802152918.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"><br>其中</p><ul><li><font color=#ff0000>红色</font> 和 <font color=#808080>灰色</font>显示的左右相同的部分，<font color=#800080>紫色</font>文字的显示的左右不同的部分；</li><li>点击上方状态栏的差别<img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190802154120.png?x-oss-process=image/resize,w_50" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190802154120.png?x-oss-process=image/resize,w_50" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"> 和 相同<img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190802154336.png?x-oss-process=image/resize,w_50" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20190802154336.png?x-oss-process=image/resize,w_50" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif">，可以分别查看对比的两个文件的有差别和相同的部分。</li></ul><h2 id="编辑器-1"><a href="#编辑器-1" class="headerlink" title="编辑器"></a>编辑器</h2><ol><li><p>印象笔记 (免费)</p><p> 笔记软件，需要付费账户才能使用全部高级功能。</p></li><li><p>Atom</p><p> GitHub自家推出的极简笔记软件，我心目中最好用的文本编辑器，用来做日常的记录，项目记录管理非常合适。支持语法高亮，git嵌入，各种插件支持。(其实他只是个文本编辑器)</p></li><li><p>Sublime Text</p><p> 文本编辑器，主要用来写前端代码。</p></li><li><p>Microsoft Excel</p><p> 制作Excel表格</p></li><li><p>Microsoft PowerPoint</p><p> 制作PPT文档</p></li><li><p>Microsoft Word</p><p> 制作Word文件</p></li><li><p>MWeb (付费)</p><p> 我挑选的最好用的MarkDown文本编辑器，支持Markdown语法格式，实时预览，iCloud同步。这篇文章就是用这个MWeb 编辑的Markdown文本。</p></li><li><p>Notability (付费)</p><p> 笔记软件。</p></li><li><p>Ulysses</p><p> 简单的文本编辑器。</p></li></ol><h2 id="常用插件-1"><a href="#常用插件-1" class="headerlink" title="常用插件"></a>常用插件</h2><ol><li>WeChatPlugin-MacOS (<a href="https://github.com/TKkk-iOSer/WeChatPlugin-MacOS">下载地址</a>)</li></ol><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>消息自动回复</li><li>消息防撤回</li><li>远程控制(已支持语音)</li><li>微信多开</li><li>第二次登录免认证</li><li>聊天置底功能(类似置顶)</li><li>微信窗口置顶</li><li>会话多选删除</li><li>自动登录开关</li><li>通知中心快捷回复</li><li>聊天窗口表情包复制 &amp; 存储</li><li>小助手检测更新提醒</li><li>alfred 快捷发送消息 &amp; 打开窗口 (需安装：wechat-alfred-workflow)</li><li>会话一键已读</li><li>一键清除空会话</li><li>支持国际化</li><li>新增一键更新</li><li>新增关于小助手</li><li>去除微信url转链（从此直接打开抖音链接🌝</li><li>史上最强 alfred 扩展🌚</li><li>新增移除会话(不删除聊天记录)</li></ul><h3 id="远程控制："><a href="#远程控制：" class="headerlink" title="远程控制："></a>远程控制：</h3><ul><li>屏幕保护</li><li>清空废纸篓</li><li>锁屏、休眠、关机、重启</li><li>退出QQ、WeChat、Chrome、Safari、所有程序</li><li>网易云音乐(播放、暂停、下一首、上一首、喜欢、取消喜欢)</li><li>小助手(获取指令、防撤回开关、自动回复开关、免认证登录开关)<br>&emsp;</li></ul><ol start="2"><li>baidu-dl (下载地址：<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN">Chrome插件商店</a>)<br> 功能：获取百度云的下载直链，可以通过浏览器直接下载百度云文件，而无需下载百度云网盘；<br> &emsp;</li><li>Full Page Screen Capture (下载地址：<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN">Chrome插件商店</a>)<br> 功能：截取浏览器网页页面长截图，方便保存网页信息，和分享；<br> &emsp;</li><li>Tampermonkey (下载地址：<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN">Chrome插件商店</a>)<br> 功能：Chrome插件中心，包含海量免费Chrome插件<br> &emsp;</li><li>Google 翻译 (下载地址:<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN">Chrome插件商店</a>)<br> 功能：双击单词翻译，划线网页文字翻译<br> &emsp;</li><li>Pixlr Today （下载地址：<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN">Chrome插件商店</a>）<br> 功能：简约好看的Chrome主页<br> &emsp;</li><li>书签侧边栏 (下载地址：<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN">Chrome插件商店</a>)<br> 功能：扩展Chrome侧边栏书签<br> &emsp;</li><li>迅雷下载支持（下载地址：<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN">Chrome插件商店</a>）<br> 功能：Everything download by 迅雷<br> &emsp;</li><li>Cocos Creator Inspector （<a href="https://github.com/tidys/CocosCreatorPlugins">GitHub下载</a>）<br> 功能：Cocos开发插件<br> &emsp;</li><li>页面自动刷新插件 （下载地址：<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN">Chrome插件商店</a>）<br>功能：自动刷新页面，抢票神器，刷页面访问量神器<br>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</li></ol><blockquote><p>持续不定期更新中…</p></blockquote>]]></content>
    
    
    <summary type="html">PDFelement 6 Pro (付费)</summary>
    
    
    
    <category term="软件" scheme="https://www.extingstudio.com/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="Mac" scheme="https://www.extingstudio.com/categories/%E8%BD%AF%E4%BB%B6/Mac/"/>
    
    
    <category term="Mac" scheme="https://www.extingstudio.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_001 两数之和</title>
    <link href="https://www.extingstudio.com/2018/09/11/2018-09-14-LeetCode_Practice_001/"/>
    <id>https://www.extingstudio.com/2018/09/11/2018-09-14-LeetCode_Practice_001/</id>
    <published>2018-09-10T16:00:00.000Z</published>
    <updated>2020-08-25T07:40:51.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p>测试用例：</p><blockquote><p>输入：[2,7,11,15] ，9<br>输出：[0，1]</p></blockquote><p>JavaScript：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var twoSum &#x3D; function(nums, target) &#123;</span><br><span class="line">    let array &#x3D; [];</span><br><span class="line">   for(let   &#x3D; 0 ; &lt; nums.length; ++)&#123;</span><br><span class="line">       for(let j &#x3D; 0;j&lt;nums.length;j++)&#123;</span><br><span class="line">           if(  !&#x3D; j)&#123;</span><br><span class="line">               if(nums[ ]+nums[j] &#x3D;&#x3D; target)&#123;</span><br><span class="line">                   array.push( );</span><br><span class="line">                   array.push(j);</span><br><span class="line">                   return array;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>记录一下LeetCode刷题练习</p></blockquote>]]></content>
    
    
    <summary type="html">1. 两数之和. 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.extingstudio.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.extingstudio.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>工作中常用到的ES6语法</title>
    <link href="https://www.extingstudio.com/2018/09/11/2018-09-10-ES6_Syntax_Commonly_Used_in_Work/"/>
    <id>https://www.extingstudio.com/2018/09/11/2018-09-10-ES6_Syntax_Commonly_Used_in_Work/</id>
    <published>2018-09-10T16:00:00.000Z</published>
    <updated>2020-08-25T07:40:26.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、let和const"><a href="#一、let和const" class="headerlink" title="一、let和const"></a>一、let和const</h1><p>在JavaScript中咱们以前主要用关键var来定义变量，ES6之后，新增了定义变量的两个关键字，分别是let和const。<br>对于变量来说，在ES5中var定义的变量会提升到作用域中所有的函数与语句前面，而ES6中let定义的变量则不会，let声明的变量会在其相应的代码块中建立一个暂时性死区，直至变量被声明。<br><code>let</code>和<code>const</code>都能够声明块级作用域，用法和<code>var</code>是类似的，let的特点是不会变量提升，而是被锁在当前块中。</p><p>一个非常简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">if(true) &#123;</span><br><span class="line">  console.log(a)&#x2F;&#x2F;TDZ，俗称临时死区，用来描述变量不提升的现象</span><br><span class="line">  let a &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">test()  &#x2F;&#x2F; a is not defined</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">    if(true) &#123;</span><br><span class="line">      let a &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(a)</span><br><span class="line">&#125;    </span><br><span class="line">test() &#x2F;&#x2F; a is not defined</span><br></pre></td></tr></table></figure><p>唯一正确的使用方法：先声明，再访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    if(true) &#123;</span><br><span class="line">      let a &#x3D; 1</span><br><span class="line">      console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p><code>const</code><br>声明常量，一旦声明，不可更改，而且常量必须初始化赋值。<br>const虽然是常量，不允许修改默认赋值，但如果定义的是对象Object，那么可以修改对象内部的属性值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const type &#x3D; &#123;</span><br><span class="line">  a: 1</span><br><span class="line">&#125;</span><br><span class="line">type.a &#x3D; 2 &#x2F;&#x2F;没有直接修改type的值，而是修改type.a的属性值，这是允许的。</span><br><span class="line">console.log(type) &#x2F;&#x2F; &#123;a: 2&#125;</span><br></pre></td></tr></table></figure><h3 id="const和let的异同点"><a href="#const和let的异同点" class="headerlink" title="const和let的异同点"></a>const和let的异同点</h3><p><strong>相同点</strong>：const和let都是在当前块内有效，执行到块外会被销毁，也不存在变量提升（TDZ），不能重复声明。<br><strong>不同点</strong>：const不能再赋值，let声明的变量可以重复赋值。<br>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><h3 id="块级作用域的使用场景"><a href="#块级作用域的使用场景" class="headerlink" title="块级作用域的使用场景"></a>块级作用域的使用场景</h3><p>除了上面提到的常用声明方式，我们还可以在循环中使用，最出名的一道面试题：循环中定时器闭包的考题<br>在for循环中使用var声明的循环变量，会跳出循环体污染当前的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for(var  &#x3D; 0;  &lt; 5; ++) &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log() &#x2F;&#x2F;5, 5, 5, 5, 5</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line">console.log() &#x2F;&#x2F;5 跳出循环体污染外部函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将var改成let之后</span><br><span class="line">for(let  &#x3D; 0;  &lt; 5; ++) &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log() &#x2F;&#x2F; 0,1,2,3,4</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line">console.log()&#x2F;&#x2F;i is not defined </span><br></pre></td></tr></table></figure><h3 id="无法污染外部函数"><a href="#无法污染外部函数" class="headerlink" title="无法污染外部函数"></a>无法污染外部函数</h3><p>在实际开发中，我们选择使用var、let还是const，取决于我们的变量是不是需要更新，通常我们希望变量保证不被恶意修改，而使用大量的const。使用const声明，声明一个对象的时候，也推荐使用const，当你需要修改声明的变量值时，使用let，var能用的场景都可以使用let替代。</p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>ES6 以前，我们知道5种基本数据类型分别是<code>Undefined</code>，<code>Null</code>，<code>Boolean</code>，<code>Number</code>以及<code>String</code>，然后加上一种引用类型<code>Object</code>构成了JavaScript中所有的数据类型，但是ES6出来之后，新增了一种数据类型，名叫<code>symbol</code>，像它的名字表露的一样，意味着独一无二，意思是每个 Symbol类型都是独一无二的，不与其它 Symbol 重复。<br>可以通过调用 Symbol() 方法将创建一个新的 Symbol 类型的值，这个值独一无二，不与任何值相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mySymbol&#x3D;Symbol();</span><br><span class="line">console.log(typeof mySymbol) &#x2F;&#x2F;&quot;symbol&quot;</span><br></pre></td></tr></table></figure><h1 id="二、字符串"><a href="#二、字符串" class="headerlink" title="二、字符串"></a>二、字符串</h1><h3 id="ES6字符串新增的方法"><a href="#ES6字符串新增的方法" class="headerlink" title="ES6字符串新增的方法"></a>ES6字符串新增的方法</h3><p><strong>UTF-16码位</strong>：ES6强制使用UTF-16字符串编码。关于UTF-16的解释请自行百度了解。</p><p>**codePointAt()**：该方法支持UTF-16，接受编码单元的位置而非字符串位置作为参数，返回与字符串中给定位置对应的码位，即一个整数值。</p><p>**String.fromCodePoiont()**：作用与codePointAt相反，检索字符串中某个字符的码位，也可以根据指定的码位生成一个字符。</p><p>**normalize()**：提供Unicode的标准形式，接受一个可选的字符串参数，指明应用某种Unicode标准形式。</p><p>在ES6中，新增了3个新方法。每个方法都接收2个参数，需要检测的子字符串，以及开始匹配的索引位置。</p><p><strong>模板字符串</strong><br>字符串是JavaScript中基本类型之一，应该算是除了对象之外是使用最为频繁的类型吧，字符串中包含了例如substr，replace，indexOf,slice等等诸多方法，ES6引入了模板字符串的特性，用反引号来表示，可以表示多行字符串以及做到文本插值（利用模板占位符）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 以前的多行字符串我们这么写：</span><br><span class="line">console.log(&quot;hello world 1\n\</span><br><span class="line">hello cala&quot;);</span><br><span class="line">&#x2F;&#x2F; &quot;hello world</span><br><span class="line">&#x2F;&#x2F; hello cala&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;有了模板字符串之后</span><br><span class="line">console.log(&#96;hello world</span><br><span class="line">string text line 2&#96;);</span><br><span class="line">&#x2F;&#x2F; &quot;hello world</span><br><span class="line">&#x2F;&#x2F; hello cala&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以用<code>$&#123;&#125;</code>来表示模板占位符，可以将你已经定义好的变量传进括弧中，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name&#x3D;&quot;cala&quot;;</span><br><span class="line">var age&#x3D;22;</span><br><span class="line">console.log(&#96;hello,I&#39;am $&#123;name&#125;,my age is $&#123;age&#125;&#96;)</span><br><span class="line">&#x2F;&#x2F;hello,I&#39;am cala,my age is 22</span><br><span class="line">includes(str, index)：如果在字符串中检测到指定文本，返回true，否则false。</span><br><span class="line"></span><br><span class="line">let t &#x3D; &#39;abcdefg&#39;</span><br><span class="line">if(t.includes(&#39;cde&#39;)) &#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>**startsWith(str, index)**：如果在字符串起始部分检测到指定文本，返回true，否则返回false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let t &#x3D; &#39;abcdefg&#39;</span><br><span class="line">if(t.startsWith(&#39;ab&#39;)) &#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;true</span><br><span class="line">endsWith(str, index)：如果在字符串的结束部分检测到指定文本，返回true，否则返回false。</span><br><span class="line"></span><br><span class="line">let t &#x3D; &#39;abcdefg&#39;</span><br><span class="line">if(t.endsWith(&#39;fg&#39;)) &#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>如果你只是需要匹配字符串中是否包含某子字符串，那么推荐使用新增的方法，如果需要找到匹配字符串的位置，使用<code>indexOf()</code>。</p><h1 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h1><h3 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h3><p>在ES5中，我们给函数传参数，然后在函数体内设置默认值，如下面这种方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function a(num, callback) &#123;</span><br><span class="line">  num &#x3D; num || 6</span><br><span class="line">  callback &#x3D; callback || function (data) &#123;console.log(&#39;ES5: &#39;, data)&#125;</span><br><span class="line">  callback(num * num)</span><br><span class="line">&#125;</span><br><span class="line">a() &#x2F;&#x2F;ES5: 36，不传参输出默认值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;你还可以这样使用callback</span><br><span class="line">a(10, function(data) &#123;</span><br><span class="line">  console.log(data * 10) &#x2F;&#x2F; 1000， 传参输出新数值</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在ES6中，我们使用新的默认值写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function a(num &#x3D; 6, callback &#x3D; function (data) &#123;console.log(&#39;ES6: &#39;, data)&#125;) &#123;</span><br><span class="line">  callback(num * num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a() &#x2F;&#x2F;ES6: 36， 不传参输出默认值</span><br><span class="line"></span><br><span class="line">a(10, function(data) &#123;</span><br><span class="line">  console.log(data * 10) &#x2F;&#x2F; 1000，传参输出新数值</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="四、箭头函数（-gt-）"><a href="#四、箭头函数（-gt-）" class="headerlink" title="四、箭头函数（=&gt;）"></a>四、箭头函数（=&gt;）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [5, 10]</span><br><span class="line">const s &#x3D; arr.reduce((sum, item) &#x3D;&gt; sum + item)</span><br><span class="line">console.log(s) &#x2F;&#x2F; 15</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>箭头函数中this的使用跟普通函数也不一样，在JavaScript的普通函数中，都会有一个自己的this值，主要分为：<br><strong>普通函数</strong>：</p><ol><li>函数作为全局函数被调用时，this指向全局对象</li><li>函数作为对象中的方法被调用时，this指向该对象</li><li>函数作为构造函数的时候，this指向构造函数new出来的新对象</li><li>还可以通过call，apply，bind改变this的指向</li></ol><p><strong>箭头函数</strong>：</p><ol><li>箭头函数没有this，函数内部的this来自于父级最近的非箭头函数，并且不能改变this的指向。</li><li>箭头函数没有super</li><li>箭头函数没有arguments</li><li>箭头函数没有new.target绑定。</li><li>不能使用new</li><li>没有原型</li><li>不支持重复的命名参数。</li></ol><h3 id="箭头函数的简单理解"><a href="#箭头函数的简单理解" class="headerlink" title="箭头函数的简单理解"></a>箭头函数的简单理解</h3><h3 id="1、箭头函数的左边表示输入的参数，右边表示输出的结果。"><a href="#1、箭头函数的左边表示输入的参数，右边表示输出的结果。" class="headerlink" title="1、箭头函数的左边表示输入的参数，右边表示输出的结果。"></a>1、箭头函数的左边表示输入的参数，右边表示输出的结果。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const s &#x3D; a &#x3D;&gt; a</span><br><span class="line">console.log(s(2)) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure><h3 id="2、在箭头函数中，this属于词法作用域，直接由上下文确定，对于普通函数中指向不定的this，箭头函数中处理this无疑更加简单，如下："><a href="#2、在箭头函数中，this属于词法作用域，直接由上下文确定，对于普通函数中指向不定的this，箭头函数中处理this无疑更加简单，如下：" class="headerlink" title="2、在箭头函数中，this属于词法作用域，直接由上下文确定，对于普通函数中指向不定的this，箭头函数中处理this无疑更加简单，如下："></a>2、在箭头函数中，this属于词法作用域，直接由上下文确定，对于普通函数中指向不定的this，箭头函数中处理this无疑更加简单，如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ES5普通函数</span><br><span class="line">function Man()&#123;</span><br><span class="line">  this.age&#x3D;22;</span><br><span class="line">  return function()&#123;</span><br><span class="line">    this.age+1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var cala&#x3D;new Man();</span><br><span class="line">console.log(cala())&#x2F;&#x2F;undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ES6箭头函数</span><br><span class="line">function Man()&#123;</span><br><span class="line">  this.age&#x3D;22;</span><br><span class="line">  return () &#x3D;&gt; this.age+1;</span><br><span class="line">&#125;</span><br><span class="line">var cala&#x3D;new Man();</span><br><span class="line">console.log(cala())&#x2F;&#x2F;23</span><br></pre></td></tr></table></figure><h3 id="3、箭头函数中没有arguments-我们可以用rest参数替代-也没有原型，也不能使用new-关键字，例如："><a href="#3、箭头函数中没有arguments-我们可以用rest参数替代-也没有原型，也不能使用new-关键字，例如：" class="headerlink" title="3、箭头函数中没有arguments(我们可以用rest参数替代),也没有原型，也不能使用new 关键字，例如："></a>3、箭头函数中没有arguments(我们可以用rest参数替代),也没有原型，也不能使用new 关键字，例如：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;没有arguments</span><br><span class="line">var foo&#x3D;(a,b)&#x3D;&gt;&#123;return arguments[0]*arguments[1]&#125;</span><br><span class="line">console.log(foo(3,5))</span><br><span class="line">&#x2F;&#x2F;arguments is not defined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;没有原型</span><br><span class="line">var Obj &#x3D; () &#x3D;&gt; &#123;&#125;;</span><br><span class="line">console.log(Obj.prototype); </span><br><span class="line">&#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不能使用new 关键字</span><br><span class="line">var Obj &#x3D; () &#x3D;&gt; &#123;&quot;hello world&quot;&#125;;</span><br><span class="line">var o &#x3D; new Obj(); </span><br><span class="line">&#x2F;&#x2F; TypeError: Obj is not a constructor</span><br></pre></td></tr></table></figure><h3 id="4、箭头函数给数组排序"><a href="#4、箭头函数给数组排序" class="headerlink" title="4、箭头函数给数组排序"></a>4、箭头函数给数组排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [10, 50, 30, 40, 20]</span><br><span class="line">const s &#x3D; arr.sort((a, b) &#x3D;&gt; a - b)</span><br><span class="line">console.log(s) &#x2F;&#x2F; [10,20,30,40,50]</span><br></pre></td></tr></table></figure><h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>尾调用是指在函数return的时候调用一个新的函数，由于尾调用的实现需要存储到内存中，在一个循环体中，如果存在函数的尾调用，你的内存可能爆满或溢出。</p><p>ES6中，引擎会帮你做好尾调用的优化工作，你不需要自己优化，但需要满足下面3个要求：<br>1、函数不是闭包<br>2、尾调用是函数最后一条语句<br>3、尾调用结果作为函数返回</p><p><strong>尾调用实际用途——递归函数优化</strong><br>在ES5时代，我们不推荐使用递归，因为递归会影响性能。<br>但是有了尾调用优化之后，递归函数的性能有了提升。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;新型尾优化写法</span><br><span class="line">&quot;use strict&quot;;  </span><br><span class="line">function a(n, p &#x3D; 1) &#123;</span><br><span class="line">  if(n &lt;&#x3D; 1) &#123;</span><br><span class="line">    return 1 * p</span><br><span class="line">  &#125;</span><br><span class="line">  let s &#x3D; n * p</span><br><span class="line">  return a(n - 1, s)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;求 1 x 2 x 3的阶乘</span><br><span class="line">let sum &#x3D; a(3)</span><br><span class="line">console.log(sum) &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure><h1 id="五、ES6对象新增方法"><a href="#五、ES6对象新增方法" class="headerlink" title="五、ES6对象新增方法"></a>五、ES6对象新增方法</h1><p><strong>Object.assign()</strong><br>Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。<br>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用<code>Object.getOwnPropertyDescriptor()</code>和<code>Object.defineProperty() </code>。<br>String类型和 Symbol 类型的属性都会被拷贝。<br>合并对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var o1 &#x3D; &#123; a: 1 &#125;;</span><br><span class="line">var o2 &#x3D; &#123; b: 2 &#125;;</span><br><span class="line">var o3 &#x3D; &#123; c: 3 &#125;;</span><br><span class="line">var obj &#x3D; Object.assign(o1, o2, o3);</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">console.log(o1);  &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>合并具有相同属性的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o1 &#x3D; &#123; a: 1, b: 1, c: 1 &#125;;</span><br><span class="line">var o2 &#x3D; &#123; b: 2, c: 2 &#125;;</span><br><span class="line">var o3 &#x3D; &#123; c: 3 &#125;;</span><br><span class="line">var obj &#x3D; Object.assign(&#123;&#125;, o1, o2, o3);</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;</span><br></pre></td></tr></table></figure><h1 id="六、Map和Set"><a href="#六、Map和Set" class="headerlink" title="六、Map和Set"></a>六、Map和Set</h1><p>Map和Set都叫做集合，但是他们也有所不同。Set常被用来检查对象中是否存在某个键名，Map集合常被用来获取已存的信息。<br>Set是有序列表，含有相互独立的非重复值。</p><h3 id="Array和Set对比"><a href="#Array和Set对比" class="headerlink" title="Array和Set对比"></a>Array和Set对比</h3><p>都是一个存储多值的容器，两者可以互相转换，但是在使用场景上有区别。如下:</p><ul><li>Array的indexOf方法比Set的has方法效率低下</li><li>Set不含有重复值（可以利用这个特性实现对一个数组的去重）</li><li>Set通过delete方法删除某个值，而Array只能通过splice。两者的使用方便程度前者更优</li><li>Array的很多新方法map、filter、some、every等是Set没有的（但是通过两者可以互相转换来使用）</li></ul><h3 id="Object和Map对比"><a href="#Object和Map对比" class="headerlink" title="Object和Map对比"></a>Object和Map对比</h3><ul><li>Object是字符串-值，Map是值-值</li><li>Object键为string类型,Map的键是任意类型</li><li>手动计算Object尺寸,Map.size可以获取尺寸</li><li>Map的排序是插入顺序</li><li>Object有原型，所以映射中有一些缺省的键。可以理解为Map=Object.create(null)</li></ul><h3 id="Set操作集合"><a href="#Set操作集合" class="headerlink" title="Set操作集合"></a>Set操作集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">let set &#x3D; new Set()</span><br><span class="line">&#x2F;&#x2F; Set转化为数组</span><br><span class="line">let arr &#x3D; Array.from(set)</span><br><span class="line">let arr &#x3D; [...set]</span><br><span class="line">&#x2F;&#x2F; 实例属性（继承自Set）</span><br><span class="line">set.constructor &#x3D;&#x3D;&#x3D; Set </span><br><span class="line">set.size </span><br><span class="line">&#x2F;&#x2F; 操作方法</span><br><span class="line">set.add(1) &#x2F;&#x2F; 添加一个值</span><br><span class="line">set.delete(1) &#x2F;&#x2F;删除一个值</span><br><span class="line">set.has(1) &#x2F;&#x2F;判断是否有这个值（Array中的indexOf）</span><br><span class="line">set.clear() &#x2F;&#x2F;清除所有值</span><br><span class="line">&#x2F;&#x2F; 获取用于遍历的成员方法(Set的遍历顺序就是插入顺序)</span><br><span class="line">set.keys() &#x2F;&#x2F; 返回键名的遍历器</span><br><span class="line">set.values() &#x2F;&#x2F; 返回键值得遍历器</span><br><span class="line">set.entries() &#x2F;&#x2F; 返回键值对的遍历器</span><br><span class="line">set.forEach() &#x2F;&#x2F; 循环遍历每个值(和Array的方法一致)</span><br><span class="line">for (let key of set.keys())&#123;&#125;</span><br><span class="line">for (let val of set.values())&#123;&#125;</span><br><span class="line">for (let entry of set.entries())&#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 使用数组方法来处理set值</span><br><span class="line">set &#x3D; new Set(arr)</span><br><span class="line">set &#x3D; new Set([...set].map((x) &#x3D;&gt; x &#x3D; x * 2))</span><br><span class="line">set &#x3D; new Set([...set].filter((x) &#x3D;&gt; x &gt; 2))</span><br><span class="line">Map的方法集合</span><br><span class="line"></span><br><span class="line">let map &#x3D; new Map()</span><br><span class="line">&#x2F;&#x2F; 实例属性(继承自Map)</span><br><span class="line">map.constructor &#x3D;&#x3D;&#x3D; Map</span><br><span class="line">map.size</span><br><span class="line">&#x2F;&#x2F; 操作方法</span><br><span class="line">map.set(1,2)</span><br><span class="line">map.get(1)</span><br><span class="line">map.delete(1)</span><br><span class="line">map.has(1)</span><br><span class="line">map.clear()</span><br><span class="line">&#x2F;&#x2F; 遍历方法</span><br><span class="line">map.keys()</span><br><span class="line">map.values()</span><br><span class="line">map.entries()</span><br><span class="line">map.forEach()</span><br><span class="line">&#x2F;&#x2F; Map和数组的转换</span><br><span class="line">map &#x3D; new Map([[&#39;key&#39;,&#39;val&#39;],[2,1]]) &#x2F;&#x2F; 要求双成员数组</span><br><span class="line">let arr &#x3D; [...map]</span><br><span class="line">&#x2F;&#x2F; 值得注意的是Map的键是跟内存绑定的</span><br><span class="line">map.set([1], &#39;s&#39;)</span><br><span class="line">map.get([1])</span><br><span class="line">let arr &#x3D; [1]</span><br><span class="line">let arr1 &#x3D; [1]</span><br><span class="line">map.set(arr, &#39;s&#39;)</span><br><span class="line">map.get(arr)</span><br><span class="line">map.set(arr1, &#39;s&#39;)</span><br><span class="line">map.get(arr1)</span><br></pre></td></tr></table></figure><h1 id="七、迭代器（Iterator）"><a href="#七、迭代器（Iterator）" class="headerlink" title="七、迭代器（Iterator）"></a>七、迭代器（Iterator）</h1><h3 id="1-entries-返回迭代器：返回键值对"><a href="#1-entries-返回迭代器：返回键值对" class="headerlink" title="1. entries() 返回迭代器：返回键值对"></a>1. entries() 返回迭代器：返回键值对</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;数组</span><br><span class="line">const arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</span><br><span class="line">for(let v of arr.entries()) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [0, &#39;a&#39;] [1, &#39;b&#39;] [2, &#39;c&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Set</span><br><span class="line">const arr &#x3D; new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);</span><br><span class="line">for(let v of arr.entries()) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [&#39;a&#39;, &#39;a&#39;] [&#39;b&#39;, &#39;b&#39;] [&#39;c&#39;, &#39;c&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Map</span><br><span class="line">const arr &#x3D; new Map();</span><br><span class="line">arr.set(&#39;a&#39;, &#39;a&#39;);</span><br><span class="line">arr.set(&#39;b&#39;, &#39;b&#39;);</span><br><span class="line">for(let v of arr.entries()) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [&#39;a&#39;, &#39;a&#39;] [&#39;b&#39;, &#39;b&#39;]</span><br></pre></td></tr></table></figure><h3 id="2-values-返回迭代器：返回键值对的value"><a href="#2-values-返回迭代器：返回键值对的value" class="headerlink" title="2.values() 返回迭代器：返回键值对的value"></a>2.values() 返回迭代器：返回键值对的value</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;数组</span><br><span class="line">const arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</span><br><span class="line">for(let v of arr.values()) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#39;a&#39; &#39;b&#39; &#39;c&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Set</span><br><span class="line">const arr &#x3D; new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);</span><br><span class="line">for(let v of arr.values()) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &#39;a&#39; &#39;b&#39; &#39;c&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Map</span><br><span class="line">const arr &#x3D; new Map();</span><br><span class="line">arr.set(&#39;a&#39;, &#39;a&#39;);</span><br><span class="line">arr.set(&#39;b&#39;, &#39;b&#39;);</span><br><span class="line">for(let v of arr.values()) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &#39;a&#39; &#39;b&#39;</span><br></pre></td></tr></table></figure><h3 id="3-keys-返回迭代器：返回键值对的key"><a href="#3-keys-返回迭代器：返回键值对的key" class="headerlink" title="3.keys() 返回迭代器：返回键值对的key"></a>3.keys() 返回迭代器：返回键值对的key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;数组</span><br><span class="line">const arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</span><br><span class="line">for(let v of arr.keys()) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0 1 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Set</span><br><span class="line">const arr &#x3D; new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);</span><br><span class="line">for(let v of arr.keys()) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &#39;a&#39; &#39;b&#39; &#39;c&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Map</span><br><span class="line">const arr &#x3D; new Map();</span><br><span class="line">arr.set(&#39;a&#39;, &#39;a&#39;);</span><br><span class="line">arr.set(&#39;b&#39;, &#39;b&#39;);</span><br><span class="line">for(let v of arr.keys()) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &#39;a&#39; &#39;b&#39;</span><br></pre></td></tr></table></figure><p>虽然上面列举了3种内建的迭代器方法，但是不同集合的类型还有自己默认的迭代器，在for of中，数组和Set的默认迭代器是<code>values()</code>，Map的默认迭代器是<code>entries()</code>。</p><p><strong>for of循环解构</strong></p><p>对象本身不支持迭代，但是我们可以自己添加一个生成器，返回一个key，value的迭代器，然后使用for of循环解构key和value。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  *[Symbol.iterator]() &#123;</span><br><span class="line">    for(let  in obj) &#123;</span><br><span class="line">      yield [, obj[]]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(let [key, value] of obj) &#123;</span><br><span class="line">  console.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &#39;a&#39; 1, &#39;b&#39; 2</span><br></pre></td></tr></table></figure><p><strong>字符串迭代器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const str &#x3D; &#39;abc&#39;;</span><br><span class="line">for(let v of str) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &#39;a&#39; &#39;b&#39; &#39;c&#39;</span><br></pre></td></tr></table></figure><p>ES6给数组添加了几个新方法：<code>find()</code>、<code>findIndex()</code>、<code>fill()</code>、<code>copyWithin()</code><br>**1.find()**：传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, &quot;2&quot;, 3, 3, &quot;2&quot;]</span><br><span class="line">console.log(arr.find(n &#x3D;&gt; typeof n &#x3D;&#x3D;&#x3D; &quot;number&quot;)) &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>**2.findIndex()**：传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, &quot;2&quot;, 3, 3, &quot;2&quot;]</span><br><span class="line">console.log(arr.findIndex(n &#x3D;&gt; typeof n &#x3D;&#x3D;&#x3D; &quot;number&quot;)) &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure><p>**3.fill()**：用新元素替换掉数组内的元素，可以指定替换下标范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.fill(value, start, end)</span><br></pre></td></tr></table></figure><p>**4.copyWithin()**：选择数组的某个下标，从该位置开始复制数组元素，默认从0开始复制。也可以指定要复制的元素范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr.copyWithin(target, start, end)</span><br><span class="line"></span><br><span class="line">const arr &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line">console.log(arr.copyWithin(3)) &#x2F;&#x2F; [1,2,3,1,2] 从下标为3的元素开始，复制数组，所以4, 5被替换成1, 2</span><br><span class="line"></span><br><span class="line">const arr1 &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line">console.log(arr1.copyWithin(3, 1)) &#x2F;&#x2F; [1,2,3,2,3] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，所以4, 5被替换成2, 3</span><br><span class="line"></span><br><span class="line">const arr2 &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line">console.log(arr2.copyWithin(3, 1, 2)) &#x2F;&#x2F; [1,2,3,2,5] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，结束位置为2，所以4被替换成2</span><br></pre></td></tr></table></figure><h1 id="八、其他"><a href="#八、其他" class="headerlink" title="八、其他"></a>八、其他</h1><p>ES6中类class、Promise与异步编程、代理（Proxy）和反射（Reflection）API</p><hr><blockquote><p>转载自：<a href="https://segmentfault.com/a/1190000016068235">学习ES6笔记──工作中常用到的ES6语法</a></p><p>原文链接：<a href="https://segmentfault.com/a/1190000016068235">https://segmentfault.com/a/1190000016068235</a></p></blockquote>]]></content>
    
    
    <summary type="html">在JavaScript中咱们以前主要用关键var来定义变量，ES6之后，新增了定义变量的两个关键字，分别是let和const。对于变量来说，在ES5中var定义的变量会提升到作用域中所有的函数与语句前面，而ES6中let定义的变量则不会，let声明的变量会在其相应的代码块中建立一个暂时性死区，直至变量被声明。let和const都能够声明块级作用域，用法和var是类似的，let的特点是不会变量提升，而是被锁在当前块中。</summary>
    
    
    
    <category term="JavaScript" scheme="https://www.extingstudio.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://www.extingstudio.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于Laya的中Timer的使用方法</title>
    <link href="https://www.extingstudio.com/2018/09/07/2018-09-07-About_Use_of_Laya_Timer/"/>
    <id>https://www.extingstudio.com/2018/09/07/2018-09-07-About_Use_of_Laya_Timer/</id>
    <published>2018-09-06T16:00:00.000Z</published>
    <updated>2020-09-03T03:03:27.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Laya中Timer的类"><a href="#Laya中Timer的类" class="headerlink" title="Laya中Timer的类"></a>Laya中Timer的类</h1><h3 id="1-官方文档"><a href="#1-官方文档" class="headerlink" title="1.官方文档 "></a>1.官方文档 <img src="https://layaair.ldc.layabox.com/api/?category=Core&class=laya.utils.Timer" class="lazyload placeholder" data-srcset="https://layaair.ldc.layabox.com/api/?category=Core&class=laya.utils.Timer" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="Laya.Timer"></h3><table><thead><tr><th>Package</th><th>laya.utils</th></tr></thead><tbody><tr><td>类</td><td>public class Timer</td></tr><tr><td>Inheritance</td><td>Timer → Object</td></tr></tbody></table><blockquote><p>Timer 是时钟管理类。它是一个单例，不要手动实例化此类，应该通过 Laya.timer 访问。</p></blockquote><table><thead><tr><th>Method</th><th>作用</th></tr></thead><tbody><tr><td>Timer()</td><td>创建 Timer 类的一个实例。</td></tr><tr><td>callLater(caller:*, method:Function, args:Array = null):void</td><td>延迟执行。</td></tr><tr><td>clear(caller:*, method:Function):void</td><td>清理定时器。</td></tr><tr><td>clearAll(caller:*):void</td><td>清理对象身上的所有定时器。</td></tr><tr><td>frameLoop(delay:int, caller:*, method:Function, args:Array = null, coverBefore:Boolean = true):void</td><td>定时重复执行(基于帧率)。</td></tr><tr><td>loop(delay:int, caller:*, method:Function, args:Array = null, coverBefore:Boolean = true, jumpFrame:Boolean = false):void</td><td>定时重复执行。</td></tr></tbody></table><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><p>新建一个正方体，加上<code>timer.loop</code>使它旋转：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180907210029.gif" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180907210029.gif" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;添加自定义模型</span><br><span class="line">        var box &#x3D; scene.addChild(new Laya.MeshSprite3D(new Laya.BoxMesh(1, 1, 1)));</span><br><span class="line">        box.transform.rotate(new Laya.Vector3(0, 45, 0), false, false);</span><br><span class="line">        var material &#x3D; new Laya.StandardMaterial();</span><br><span class="line">        material.diffuseTexture &#x3D; Laya.Texture2D.load(&quot;res&#x2F;layabox.png&quot;);</span><br><span class="line">        box.meshRender.material &#x3D; material;</span><br><span class="line"></span><br><span class="line">        let func &#x3D; function () &#123;</span><br><span class="line">            box.transform.rotate(new Laya.Vector3(0, 0.01, 0));</span><br><span class="line">        &#125;;</span><br><span class="line">        Laya.timer.loop(1, this, func);</span><br></pre></td></tr></table></figure><p>添加clearAll()方法，使用setTimeOut两秒后clear掉定时器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&#39;清理定时器&#39;);</span><br><span class="line">    Laya.timer.clear(this, func);</span><br><span class="line">&#125;, 2000);</span><br></pre></td></tr></table></figure><p><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180907210514.gif" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180907210514.gif" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h3><p>在使用laya.timer.loop之前，一定要先clear掉之前的定时器，否则会出现不可预期的BUG</p>]]></content>
    
    
    <summary type="html">在使用laya.timer.loop之前，一定要先clear掉之前的定时器，否则会出现不可预期的BUG</summary>
    
    
    
    <category term="游戏" scheme="https://www.extingstudio.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="LayaBox" scheme="https://www.extingstudio.com/categories/LayaBox/"/>
    
    
    <category term="LayaBox" scheme="https://www.extingstudio.com/tags/LayaBox/"/>
    
  </entry>
  
  <entry>
    <title>使用Google Closure Compiler进行Js代码压缩</title>
    <link href="https://www.extingstudio.com/2018/09/03/2018-09-03-JS_Minify_With_Google_Closure_Compiler/"/>
    <id>https://www.extingstudio.com/2018/09/03/2018-09-03-JS_Minify_With_Google_Closure_Compiler/</id>
    <published>2018-09-02T16:00:00.000Z</published>
    <updated>2020-08-25T07:39:15.135Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Google-Closure-Compiler是什么？"><a href="#1-Google-Closure-Compiler是什么？" class="headerlink" title="1.Google Closure Compiler是什么？"></a>1.Google Closure Compiler是什么？</h3><blockquote><p>The Closure Compiler is a tool for making JavaScript download and run faster. Instead of compiling from a source language to machine code, it compiles from JavaScript to better JavaScript. It parses your JavaScript, analyzes it, removes dead code and rewrites and minimizes what’s left. It also checks syntax, variable references, and types, and warns about common JavaScript pitfalls.</p><p>Closure Compiler是一个使JavaScript下载和运行更快的工具。 它不是从源语言编译到机器代码，而是从JavaScript编译成更好的JavaScript。 它解析您的JavaScript，分析它，删除死代码并重写并最小化剩下的内容。 它还检查语法，变量引用和类型，并警告常见的JavaScript陷阱。 </p></blockquote><h3 id="2-使用环境"><a href="#2-使用环境" class="headerlink" title="2.使用环境"></a>2.使用环境</h3><p>  平台：Mac OS<br>  <br>环境：Java</p><h3 id="3-检查是否安装了Java环境"><a href="#3-检查是否安装了Java环境" class="headerlink" title="3.检查是否安装了Java环境"></a>3.检查是否安装了Java环境</h3><p>打开终端，输入 <code>java -version</code>,输出java的版本说明已安装好了java，若报错，请安装java环境<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180903132733.png?x-oss-process=image/resize,w_500" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180903132733.png?x-oss-process=image/resize,w_500" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><h3 id="4-Closure-Compiler下载"><a href="#4-Closure-Compiler下载" class="headerlink" title="4.Closure Compiler下载"></a>4.Closure Compiler下载</h3><p>在<a href="https://dl.google.com/closure-compiler/compiler-latest.zip">Github</a>上下载最新版的编译好的Compiler文件，解压出jar文件存放在项目外的目录下：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180903131934.png?x-oss-process=image/resize,w_300" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180903131934.png?x-oss-process=image/resize,w_300" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="compiler"></p><h3 id="5-在终端中，输入命令，运行jar："><a href="#5-在终端中，输入命令，运行jar：" class="headerlink" title="5.在终端中，输入命令，运行jar："></a>5.在终端中，输入命令，运行jar：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar &#x2F;Users&#x2F;wangjun&#x2F;Git&#x2F;compiler.jar --js_output_file&#x3D;code.js &#39;&#x2F;Users&#x2F;wangjun&#x2F;Git&#x2F;WorkProject&#x2F;BallsRace&#x2F;release&#x2F;wxgame&#x2F;code.js&#39;</span><br></pre></td></tr></table></figure><p><code>/Users/wangjun/Git/compiler.jar</code> 改为自己的电脑上compiler.jar的路径，<code>code.js</code>改为输出文件名，<code>/Users/wangjun/Git/WorkProject/BallsRace/release/wxgame/code.js</code>改为输出路径。（其他参数这里使用默认）<br>运行后就可以看到生成了压缩的JS文件了。<br>压缩前后文件大小对比，压缩效果还是很明显的：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180903133758.png?x-oss-process=image/resize,w_300" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180903133758.png?x-oss-process=image/resize,w_300" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180903133906.png?x-oss-process=image/resize,w_310" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180903133906.png?x-oss-process=image/resize,w_310" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><h3 id="6-使用sh脚本实现自动化打包压缩Js文件"><a href="#6-使用sh脚本实现自动化打包压缩Js文件" class="headerlink" title="6.使用sh脚本实现自动化打包压缩Js文件"></a>6.使用sh脚本实现自动化打包压缩Js文件</h3><p>由于我是使用Laya Box引擎做游戏开发的，每次打包都需要手动敲代码进行代码压缩，并且还需要手动删除打包后多余的库文件，流程实在很繁琐，所以我使用了Laya打包提供的后续执行命令功能，配合sh命令进行了打包压缩的自动化，大大提高了打包效率。<br>打开Laya Box的打包页面<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180903134500.png?x-oss-process=image/resize,w_400" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180903134500.png?x-oss-process=image/resize,w_400" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"><br>编写sh命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;Users&#x2F;wangjun&#x2F;Git&#x2F;WorkProject&#x2F;BallsRace&#x2F;release&#x2F;wxgame&#x2F;</span><br><span class="line">rm -rf .&#x2F;libs</span><br><span class="line">rm -rf .&#x2F;res</span><br><span class="line">java -jar &#x2F;Users&#x2F;wangjun&#x2F;Git&#x2F;compiler.jar --js_output_file&#x3D;code.js &#39;&#x2F;Users&#x2F;wangjun&#x2F;Git&#x2F;WorkProject&#x2F;BallsRace&#x2F;release&#x2F;wxgame&#x2F;code.js&#39;</span><br></pre></td></tr></table></figure><p>保存为.sh文件<br>在后续执行脚本中填入.sh脚本的路径，在打包后就可以自动执行代码压缩，并且删除多余文件了。</p><h3 id="7-帮助"><a href="#7-帮助" class="headerlink" title="7.帮助"></a>7.帮助</h3><p>在终端中输入 <code>java -jar compiler.jar --help</code> 可以查看compiler的命令帮助和其他参数<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180903134930.png?x-oss-process=image/resize,w_400" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180903134930.png?x-oss-process=image/resize,w_400" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"></p><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8.其他"></a>8.其他</h3><p>我没用使用各种在线的Js代码压缩网站，原因如下：</p><ol><li>在线压缩工具受网络状况影响；</li><li>和我的需求不一致，我需要的是压缩js文件，而不只是压缩js代码片段；</li><li>无法实现自动化脚本，上传-等待-压缩-下载，比较繁琐；</li><li>我觉得上传代码压缩并不安全，有泄漏源码的风险。</li></ol><h3 id="9-其他的JavaScript代码压缩工具"><a href="#9-其他的JavaScript代码压缩工具" class="headerlink" title="9.其他的JavaScript代码压缩工具"></a>9.其他的JavaScript代码压缩工具</h3><p><a href="https://github.com/mishoo/UglifyJS">UglifyJS</a><br><br><a href="https://github.com/yui/yuicompressor">YUI Compressor</a><br><br><a href="http://25.io/smaller/">Smaller</a><br><br><a href="https://github.com/GGG-KILLER/CSS-And-Js-Minifier">Minifier</a></p>]]></content>
    
    
    <summary type="html">The Closure Compiler is a tool for making JavaScript download and run faster. Instead of compiling from a source language to machine code, it compiles from JavaScript to better JavaScript. It parses your JavaScript, analyzes it, removes dead code and rewrites and minimizes what&#39;s left. It also checks syntax, variable references, and types, and warns about common JavaScript pitfalls.</summary>
    
    
    
    <category term="JavaScript" scheme="https://www.extingstudio.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://www.extingstudio.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>什么是WebSocket？</title>
    <link href="https://www.extingstudio.com/2018/08/27/2018-01-25-About_WebSocket/"/>
    <id>https://www.extingstudio.com/2018/08/27/2018-01-25-About_WebSocket/</id>
    <published>2018-08-26T16:00:00.000Z</published>
    <updated>2020-08-25T07:35:35.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是WebSocket？"><a href="#什么是WebSocket？" class="headerlink" title="什么是WebSocket？"></a>什么是WebSocket？</h1><p>　</p><blockquote><p>　WebSocket协议是一种基于ＴＣＰ的一种新的网络协议。他实现了浏览器与服务器全双工(full-duplex)通信—-允许服务器主动发送信息给客户端。</p><p>　　　　　　　　　　　　　　　　　　　　　　　—-百度百科</p></blockquote><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>　　在实现websocket连线过程中，需要通过浏览器发出websocket连线请求，然后服务器发出回应，这个过程通常称为“握手” 。在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处：</p><h3 id="1-Header"><a href="#1-Header" class="headerlink" title="1. Header"></a>1. Header</h3><p>　　互相沟通的Header是很小的-大概只有 2 Bytes。</p><h3 id="2-Server-Push"><a href="#2-Server-Push" class="headerlink" title="2. Server Push"></a>2. Server Push</h3><p>　　服务器的推送，服务器不再被动的接收到浏览器的请求之后才返回数据，而是在有新数据时就主动推送给浏览器。</p><p>WebSocket与消息推送 - 张果 - 博客园<br><a href="https://www.cnblogs.com/best/archive/2016/09/12/5695570.html#_label2">https://www.cnblogs.com/best/archive/2016/09/12/5695570.html#_label2</a></p>]]></content>
    
    
    <summary type="html">在实现websocket连线过程中，需要通过浏览器发出websocket连线请求，然后服务器发出回应，这个过程通常称为“握手” 。在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处</summary>
    
    
    
    <category term="网络" scheme="https://www.extingstudio.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://www.extingstudio.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>使用MWeb进行Markdown博客编辑</title>
    <link href="https://www.extingstudio.com/2018/08/27/2018-08-25-Mweb_for_markdown_on_mac/"/>
    <id>https://www.extingstudio.com/2018/08/27/2018-08-25-Mweb_for_markdown_on_mac/</id>
    <published>2018-08-26T16:00:00.000Z</published>
    <updated>2020-08-25T07:39:07.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎使用-MWeb"><a href="#欢迎使用-MWeb" class="headerlink" title="欢迎使用 MWeb"></a>欢迎使用 MWeb</h1><p>MWeb 是专业的 Markdown 写作、记笔记、静态博客生成软件，目前已支持 Mac，iPad 和 iPhone。MWeb 有以下特色：</p><h2 id="软件本身："><a href="#软件本身：" class="headerlink" title="软件本身："></a>软件本身：</h2><ul><li>使用原生的 macOS 技术打造，追求与系统的完美结合。</li><li>原则上，首先是追求界面简洁和高性能，然后才是强大易用，功能全面。</li></ul><h2 id="Markdown-语法："><a href="#Markdown-语法：" class="headerlink" title="Markdown 语法："></a>Markdown 语法：</h2><ul><li>使用 Github Flavored Markdown 语法，简称 GFM 语法。</li><li>支持表格、TOC、LaTeX、代码块、任务列表、脚注等。</li><li>画图库支持 mermaid, viz, echarts, plantuml, sequence, flow。</li></ul><h2 id="Markdown-辅助："><a href="#Markdown-辅助：" class="headerlink" title="Markdown 辅助："></a>Markdown 辅助：</h2><ul><li>支持截图并粘贴、复制并粘贴、拖拽等方式插入图片并直接显示在编辑器内。</li><li>在兼容 Markdown 语法的情况下支持设置图片宽度。</li><li>好用的表格插入和 LaTeX 书写辅助。</li></ul><h2 id="Markdown-输出："><a href="#Markdown-输出：" class="headerlink" title="Markdown 输出："></a>Markdown 输出：</h2><ul><li>支持导出为图片、HTML、Epub、PDF、RTF、Docx。</li><li>支持发布到 Wordrpess、支持 Metaweblog API 协议的服务、Wordpress.com、印象笔记（Evernote）、Blogger、Medium、Tumblr。</li><li>图片上传服务（图床）支持 Google Photos、Imgur、七牛云、又拍云和自定义的图床服务。</li></ul><h2 id="Markdown-笔记："><a href="#Markdown-笔记：" class="headerlink" title="Markdown 笔记："></a>Markdown 笔记：</h2><ul><li>强大的文档库支持分类树和标签管理文档，文档可归类于多个分类，可以把分类整个导出为 Epub、PDF 和生成静态网站。非常合适用于笔记、个人知识收集、管理和输出。</li><li>快速笔记：随意增加笔记及图片等素材，支持以天为单位把增加的素材组合在一个文档内，方便整理及记录历史收集情况。</li><li>快速搜索：目前已支持全局快捷键调出搜索。</li></ul><h2 id="外部-Markdown-文档："><a href="#外部-Markdown-文档：" class="headerlink" title="外部 Markdown 文档："></a>外部 Markdown 文档：</h2><ul><li>外部 Markdown 文档使用外部模式管理。外部模式使用目录树的方式编辑和管理你的 markdown 文档，还能很好的支持 gitbook、JekyII、hexo 等等编辑和图片插入。</li></ul><h2 id="MWeb-文档："><a href="#MWeb-文档：" class="headerlink" title="MWeb 文档："></a>MWeb 文档：</h2><p>如果要更详细了解 MWeb，建议你一定要去看一下官网的帮助文档，网址为：<a href="https://zh.mweb.im/help.html">https://zh.mweb.im/help.html</a>。我们建议在使用文档库之前，一定要阅读一下  <a href="https://zh.mweb.im/mweb-library.html">MWeb 文档库详细介绍</a> 这篇文章，以便更好的使用文档库。</p>]]></content>
    
    
    <summary type="html">MWeb 是专业的 Markdown 写作、记笔记、静态博客生成软件，目前已支持 Mac，iPad 和 iPhone。MWeb 有以下特色</summary>
    
    
    
    <category term="博客" scheme="https://www.extingstudio.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://www.extingstudio.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>关于游戏状态同步</title>
    <link href="https://www.extingstudio.com/2017/09/05/2018-01-23-Game_State_Sync/"/>
    <id>https://www.extingstudio.com/2017/09/05/2018-01-23-Game_State_Sync/</id>
    <published>2017-09-04T16:00:00.000Z</published>
    <updated>2020-08-25T07:35:19.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于游戏状态同步"><a href="#关于游戏状态同步" class="headerlink" title="关于游戏状态同步"></a>关于游戏状态同步</h2><ol><li><p><strong>如何进行网络同步？</strong></p><p>状态同步： 状态同步 的关键在于服务器维护整个游戏逻辑，客户端相当于遥控器对游戏服务器发送指令，当服务器状态发生变化时，向玩家发送消息，玩家端仅展示动画。</p><p>帧同步： 帧同步中服务器不处理游戏逻辑，仅转发玩家的包。游戏客户端需要处理所有的游戏逻辑。帧同步适用于及时性比较强的游戏。</p><p>回合同步： 回合同步类似于帧同步，也是在服务端进行计算，但仅仅在发生动作时向服务器发送自己的动作。</p><p>轨迹同步： 轨迹同步即服务端记录玩家的轨迹，一个客户端请求另一个客户端的轨迹，适用于玩家之间没有相互影响的游戏。</p></li></ol>]]></content>
    
    
    <summary type="html">状态同步： 状态同步 的关键在于服务器维护整个游戏逻辑，客户端相当于遥控器对游戏服务器发送指令，当服务器状态发生变化时，向玩家发送消息，玩家端仅展示动画。</summary>
    
    
    
    <category term="游戏" scheme="https://www.extingstudio.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="游戏" scheme="https://www.extingstudio.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Jekyll搭建个人博客</title>
    <link href="https://www.extingstudio.com/2017/09/05/2018-08-25-jekyll_tutorials/"/>
    <id>https://www.extingstudio.com/2017/09/05/2018-08-25-jekyll_tutorials/</id>
    <published>2017-09-04T16:00:00.000Z</published>
    <updated>2020-08-25T07:38:25.221Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要讲的是如何使用和修改我的博客主题，文章内容含以下几点：</p><ul><li>修改博客基础信息</li><li>发布文章</li><li>修改博客样式</li><li>添加文章字数统计和阅读时间估算</li><li>添加网易云音乐播放插件</li></ul><p>博客模板根目录下的基本结构为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml </span><br><span class="line">├── _includes    </span><br><span class="line">├── _layouts</span><br><span class="line">├── _posts</span><br><span class="line">├── _site</span><br><span class="line">├── 404.html</span><br><span class="line">├── about.md</span><br><span class="line">├── archive.html</span><br><span class="line">├── CNAME</span><br><span class="line">├── css</span><br><span class="line">├── feed.xml</span><br><span class="line">├── Gemfile</span><br><span class="line">├── Gemfile.lock</span><br><span class="line">├── images</span><br><span class="line">├── index.html</span><br><span class="line">├── js</span><br><span class="line">├── Rakefile</span><br><span class="line">├── README.md</span><br><span class="line">└── tags.html</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>_config.yml 是博客的配置文件，内容如图所示<br> <img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180902002437.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180902002437.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif" alt="blogcreenshot"><br>title：网站名称<br><br>subtitle：网站副标题<br><br>desciption：网站描述<br><br>avatarTitle：头像标题<br><br>avatarDesc：头像描述<br><br>url：网站链接<br><br>comment：评论系统，这里我是用的是国外的Disqus和livere，由于“众所周知”的原因，Disqus评论系统在国内并不可用，需要梯子才可以访问，虽然Disqus很好用==，所以我目前是使用的livere(来必力，韩国开发的)，相关配置和使用教程会在以后放出来。国内也有（大概？）好用的评论系统，例如：畅言、Valine等，可以自行测试使用。<br><br>social：社交账号<br><br>baidu：网站统计<br><br>ga：Google Analytics谷歌网站分析<br></li><li>_includes/ 是网站模板包含的样式目录</li><li>_layout/ 是网站模板的样式模板目录</li><li>_post/ 是博客的文章目录，写好的markdown文件放在此目录，推送到github上，文章即可在博客上展示</li><li>_site/ 是网站的发布目录</li><li>404.html 404页面</li><li>about.md 关于我 页面</li><li>archive.html 文章发布页面</li><li>CNAME cname域名转发，可以在Github上直接设置</li><li>css,feed.html RSS订阅页面</li><li>images 图片存储目录，可以存储文章引用的图片</li><li>index.html 主页入口</li><li>js/ js文件目录</li><li>README.md Github readme页面</li><li>tags.html 博客tags<h3 id="添加文章字数统计和阅读时间"><a href="#添加文章字数统计和阅读时间" class="headerlink" title="添加文章字数统计和阅读时间"></a>添加文章字数统计和阅读时间</h3>在_layouts目录下的post.html中，添加代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;span &gt;本文总字数:&#123;&#123; page.content | strip_html | strip_newlines | remove: &quot; &quot; | size &#125;&#125;字 | &lt;&#x2F;span&gt;</span><br><span class="line">&lt;span &gt;阅读完需要约&#123;&#123; page.content | strip_html | strip_newlines | remove: &quot; &quot; | size | divided_by: 350 | plus: 1 &#125;&#125;分钟&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>在文章的发布之后即可显示文章字数统计和阅读时间统计：<br><img src="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180902150257.png" class="lazyload placeholder" data-srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/20180902150257.png" srcset="https://es-blogimg.oss-cn-hangzhou.aliyuncs.com/img/icon/img-loading-bilibili.gif"><h3 id="添加网易云音乐播放插件"><a href="#添加网易云音乐播放插件" class="headerlink" title="添加网易云音乐播放插件"></a>添加网易云音乐播放插件</h3>在_includes目录下，添加html文件 cloud-music.html<br>内容为：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- cloud music --&gt;</span><br><span class="line">&lt;!-- auto&#x3D;1 可以控制自动播放与否，当值为 1 即打开网页就自动播放，值为 0 时需要访客手动点击播放 --&gt;</span><br><span class="line">&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;330 height&#x3D;86</span><br><span class="line">        src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;2&amp;id&#x3D;&#123;&#123; page.music-id &#125;&#125;&amp;auto&#x3D;1&amp;height&#x3D;66&quot;&gt;</span><br><span class="line">&lt;&#x2F;iframe&gt;</span><br></pre></td></tr></table></figure><p>在post.html，文章正文的开头，添加代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;&quot;center&quot;&gt; </span><br><span class="line">    &lt;!-- 在正文开头添加网易云音乐插件 --&gt;</span><br><span class="line">  &#123;% if page.music-id %&#125;</span><br><span class="line">    &#123;% include cloud-music.html %&#125;</span><br><span class="line">  &#123;% endif %&#125; </span><br><span class="line">    &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>在正文的markdown文本中，开头加上：</p><p><code>music-id: 496869422 </code></p><p>就可以在文章的开头显示网易云音乐播放器，music-id是音乐id，可以在网易云音乐播放器中查找<br><br><br><br><br><br><br><br><br><br></p><blockquote><p>待更新</p></blockquote>]]></content>
    
    
    <summary type="html">这篇文章主要讲的是如何使用和修改我的博客主题，文章内容含以下几点</summary>
    
    
    
    <category term="博客" scheme="https://www.extingstudio.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://www.extingstudio.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
